<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>小生很忙</title>
    <link>https://chaoge123456.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>网络安全和机器学习相关技术分享</description>
    <pubDate>Fri, 30 Nov 2018 18:38:43 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>tor匿名网络</title>
      <link>https://chaoge123456.github.io/Tor%E5%8C%BF%E5%90%8D%E7%BD%91%E7%BB%9C.html/</link>
      <guid>https://chaoge123456.github.io/Tor%E5%8C%BF%E5%90%8D%E7%BD%91%E7%BB%9C.html/</guid>
      <pubDate>Wed, 28 Nov 2018 19:14:32 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt; 前段时间看到一篇报道，暗网最大的托管商遭到黑客攻击，6500+网站被删。根据知道创宇平台的暗网雷达显示，一夜之间活跃在暗网中的网站从12000+下降到5000+，几乎遭到团灭，这一事件让暗网再次进入人们的视野。一直以来，暗网被赋予了
        
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>摘要：</strong> 前段时间看到一篇报道，暗网最大的托管商遭到黑客攻击，6500+网站被删。根据知道创宇平台的暗网雷达显示，一夜之间活跃在暗网中的网站从12000+下降到5000+，几乎遭到团灭，这一事件让暗网再次进入人们的视野。一直以来，暗网被赋予了很多传奇的色彩，本文将带你一步步揭开暗网的神秘面纱。</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/tor/tor.jpg" alt="avatar"></p><hr><h2 id="文章概览"><a href="#文章概览" class="headerlink" title="文章概览"></a>文章概览</h2><ul><li>基本概念<ul><li>深网</li><li>暗网</li><li>黑暗网络</li></ul></li><li>tor匿名网络 <ul><li>tor基本概述</li><li>tor网络结构</li><li>tor路由技术</li><li>tor匿名服务</li></ul></li><li>tor客户端代理</li></ul><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>&emsp;&emsp;在介绍暗网之前，我们先来了解一下经常会混淆的三个概念“深网”(Deep web)、“暗网”(Dark web) 和“黑暗网络”(Darknet) 。</p><h4 id="深网"><a href="#深网" class="headerlink" title="深网"></a>深网</h4><p>&emsp;&emsp;深网是指服务器上可通过标准的网络浏览器和连接方法访问的页面和服务，但主流搜索引擎不会收录这些页面和服务。搜索引擎之所以不会收录深网，通常是因为网站或服务的配置错误、拒绝爬虫爬取信息、需要付费查看、需要注册查看或其他内容访问限制。据不完全统计，互联网世界中只有4％是对公众开放，剩下的96％的网站和数据则隐藏在深网中。</p><h4 id="暗网"><a href="#暗网" class="headerlink" title="暗网"></a>暗网</h4><p>&emsp;&emsp;暗网是深网中相对较小的一部分，与被故意隐藏的 Web 服务和页面有关。仅使用标准浏览器无法直接访问这些服务和页面，必须依靠使用覆盖网络 (Overlay Network)；而这种网络需要特定访问权限、代理配置、专用软件或特殊网络协议。</p><h4 id="黑暗网络"><a href="#黑暗网络" class="headerlink" title="黑暗网络"></a>黑暗网络</h4><p>&emsp;&emsp;黑暗网络是在网络层访问受限的框架，例如 tor 或 I2P，私有 VPN 也属于这个类别。通过这些框架的网络流量会被屏蔽。当进行数据传输时，系统只会显示您连接的黑暗网络以及您传输了多少数据，而不一定会显示您访问的网站或所涉及数据的内容。与之相反的是，直接与明网（Clean Net）或与未加密的表网服务和深网服务交互。在这种情况下，您与所请求资源之间的互联网服务提供商和网络运营商可以看到您传输的流量内容。</p><h3 id="tor匿名网络"><a href="#tor匿名网络" class="headerlink" title="tor匿名网络"></a>tor匿名网络</h3><h4 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h4><p>&emsp;&emsp;经过上面的描述，我们对暗网整体的框架有个大致的了解。暗网不同于普通的互联网络，它拥有特殊的运作方式和网络协议，tor 是目前世界范围内是最大的暗网。tor又名洋葱网络，最初是由美国军方的情报机构开发并且提供财务支持的。洋葱网络使用特殊的路由转发技术，即洋葱路由技术。洋葱路由技术利用 P2P 网络,把网络流量随机地通过 P2P 的节点进行转发，这样可以掩盖源地址与目标地址的路径，使得在 Internet 上难以确定使用者的身份和地址。这就类似于你给某人送一封匿名信，你不是自己去送或者通过邮局的邮差去送，而是在大街上随便找几个不认识的人让他帮你送，这样收信人就很难往回追踪找到你。</p><p>&emsp;&emsp;洋葱路由项目最初进展缓慢,废弃了其中的几个版本。直到 2002 年才由麻省理工的两位毕业生 Roger Dingledine 和 Nick Mathewson 以及原项目组成员 PaulSyverson 一起开发出一个新版的洋葱路由，也就是Tor。“洋葱路由”的最初目的并不是保护大众的隐私，它的目的是帮助政府情报人员隐藏身份，网上活动不被敌对国家监控。后来为了混淆系统的流量，而不是让系统仅仅拥有来自美国安全部门网络的流量，他们又让系统中加入来自其它网络的流量。于是，tor 的普通版本被推广给了普通大众，让普通大众也能使用 tor 来保护自己的隐私。这样就可以把政府情报人员的流量与社会上各行各业用户的复杂流量混在一起，能让流量分析更加困难，提供更强地隐私保护。</p><p>&emsp;&emsp;目前全球范围内，tor网络由超过一万七千个中继节点组成，每个中继节点都是由全球志愿者免费提供，这些中继节点大部分分布在欧洲和北美。暗网除了能给我们提供匿名的网络服务之外，在按暗网中也存在各种类型的网站，这些网站只有通过暗网才能够访问。暗网中的网站大部分都是提供一些“特殊的服务”，包括枪支、毒品、网络攻击等等。</p><h4 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h4><p>Tor 匿名网络结构主要由目录服务器、洋葱代理、洋葱路由器这三部分组成。</p><ul><li><strong>目录服务器：</strong>它负责收集和更新网络中所有可运行的中继节点信息，为客户端提供节点公钥等建立链路所需的必要信息。目前，绝大多数的目录服务器在欧美地区,只有极少数分布在亚洲。</li><li><strong>洋葱代理：</strong>它是 tor 用户的客户端代理程序，负责下载目录服务器中的路由信息，选择节点和建立路径，并对通信信息进行加解密。</li><li><strong>洋葱路由器（又称中继节点）：</strong>它是构建匿名通信链路的基础，负责转发 tor 客户端和网络服务器的通信信息，是实现匿名通信的关键。目前整个 tor 网络中有几千个路由节点分布在世界各地，这些中继节点又分为三种类型:<ul><li>Entry/Guard 中继节点──这是 tor 网络的入口节点。这些中继节点运行一段时间后，如果被证明是稳定的，并具有高带宽，就会被选来作为 Guard 中继节点。</li><li>Middle 中继节点──Middle 中继节点是位于中间节点位置上的洋葱路由器，充当流量从 Guard 中继节点传输到 Exit 中继节点的桥梁，这可以避免 Guard 中继节点和 Exit 中继节点探查到彼此的位置。</li><li>Exit 中继节点──位于出口节点位置上的洋葱路由器，负责将 Tor 网络内的流量转发到网络外部的互联网中去。每个出口节点都有一个相关的出口政策，该政策规定该节点能通过哪个端口转发何种协议的流量来防止滥用 tor 网络。</li></ul></li></ul><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/tor/tor_structure.jpeg" alt="avatar"></p><p>&emsp;&emsp;tor 网络主要依赖于这些中继节点转发用户流量，tor 通过随机选取遍布于全球由志愿者运行的三个中继节点，然后分别与选择的入口节点、中间节点、出口节点协商会话密钥。用这些协商的密钥将通信数据先进行多层加密，然后再将加密的数据在三个洋葱路由器组成的通信链路上传送。数据每经过一个洋葱路由器就像是剥去一层洋葱皮一样解密去掉一个加密层，以此得到下一跳路由信息，然后将数据继续发往下一个洋葱路由器，不断重复此过程,直到数据送达目的地。这种转发方式能防止那些知道数据发送端以及接收端的中间人窃听数据内容。</p><h4 id="tor路由技术"><a href="#tor路由技术" class="headerlink" title="tor路由技术"></a>tor路由技术</h4><p>以下步骤讲述了Alice在使用tor与Bob的服务器进行通讯时，tor是如何工作的。</p><ul><li>Alice开启tor客户端代理，获取来自tor 目录服务器（Dave）中的tor节点（或中继的列表）以及它们的公钥。</li></ul><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/tor/tor_work1.png" alt="avatar"></p><ul><li>Alice 选择三个节点建立通信链路。Alice 得到入口中继节点的 IP 地址和身份摘要，和入口节点协商一个只用于两者之间通信的短暂会话密钥。成功建立一跳的链路以后，Alice 使用同样地方法要求入口节点拓展链路到中间节点，得到了 Alice与中间节点的短暂会话密钥。Alice 重复此过程直至建立一条含有三跳的通信链路并且获得三个她与三个节点独一无二的短暂会话密钥。整个链路建立过程中的所有连接都是加密的。然后Alice 向 Bob 发送服务请求，并且将请求内容使用三个会话密钥按由远到近的顺序依次加密。入口节点接收到解密消息后会使用会话密钥将其解密一层，并将仍然加密的信息转发给中间节点。直至到达出口节点后，才将信息解密为明文。图中的虚线表示出口节点与 Bob 之间的连接是未加密的，出口节点将原始数据发送给 Bob。Bob 回复请求内容，并且每个节点会以相反的加密顺序加密一层,最终送还给 Alice。</li></ul><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/tor/tor_work2.png" alt="avatar"></p><ul><li>如果 Alice 与 Bob 通信时间较长，Alice 每隔几分钟会重新选择三个节点建立新的通信链路以防攻击者窃听。如果 Alice 想要访问另一服务器 Jane，她也会重新选择中继节点建立新的通信链路。</li></ul><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/tor/tor_work3.png" alt="avatar"></p><h4 id="tor匿名服务"><a href="#tor匿名服务" class="headerlink" title="tor匿名服务"></a>tor匿名服务</h4><p>&emsp;&emsp;之前提到暗网中也存在很多网站，这些网站在提供相应的服务时（暗网中大部分网络服务都是违法的）也希望是匿名的，即用户无法追踪到关于该网站的相关信息。下面主要讲解用户Alice和匿名服务器Bob交互的具体过程。</p><ul><li>服务器Bob与tor网络中的一些中继节点连接，请求这些中继节点作为匿名服务的接入点，并将Bob的公钥发送给这些中继节点。注意Bob和中继节点之间的连接也是匿名的，这些中继节点无法获取关于Bob的相关位置信息。</li></ul><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/tor/THS-1.png" alt="avatar"></p><ul><li>Bob将之前建立的接入点的相关信息和自己的公钥组装成描述符，并用自己的私钥该描述符进行签名，然后将其发送到目录服务器。通过Bob的公钥可以生成一个16位的字符串，记为XYZ。当客户端请求XYZ.onion时就可以找到对应Bob的描述符。</li></ul><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/tor/THS-2.png" alt="avatar"></p><ul><li>Alice通过某些渠道获得了tor域名XYZ.onion，Alice想要访问该服务器。她通过tor客户端访问XYZ.onion，此时可以从目录服务器中获取对应服务器的描述符，通过描述符可以知道Bob服务器的接入点和公钥。与此同时，Alice会提前建立另外一条私密临时会话点，用于下一步与Bob交互。</li></ul><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/tor/THS-3.png" alt="avatar"></p><ul><li>当确认描述符存在且临时通道准备好之后，Alice用描述符中的公钥加密一条信息，包括临时会话点和会话秘钥，将加密后的信息发送给描述符中的接入点，之后接入点会将加密信息发送到对应的服务器（即Bob的服务器）。</li></ul><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/tor/THS-4.png" alt="avatar"></p><ul><li>Bob收到加密信息后将其解密，获取临时会话点和会话秘钥。然后和临时会话点建立匿名连接，连接成功后，临时会话点会通知Alice。之后Alice和Bob可以通过临时会话点进行通信，注意通信过程中建立的连接都是匿名的。</li></ul><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/tor/THS-5.png" alt="avatar"></p><h3 id="tor客户端代理"><a href="#tor客户端代理" class="headerlink" title="tor客户端代理"></a>tor客户端代理</h3><p>&emsp;&emsp;如果只是希望匿名浏览web网页，我们可以通过<a href="https://www.torproject.org/projects/torbrowser.html.en" target="_blank" rel="noopener">tor浏览器</a>来实现。tor浏览器是基于火狐浏览器改造而来，可以方便的帮助我们连接到tor，实现网络匿名。如果想要在更多应用中实现网络匿名，我们可以安装tor客户端代理。以下配置过程基于ubuntu，且默认已安装shadowsocks。</p><h4 id="安装polipo"><a href="#安装polipo" class="headerlink" title="安装polipo"></a>安装polipo</h4><p>&emsp;&emsp;polipo是轻量级的跨平台代理服务器，可以实现http和socks代理，polipo本地服务端口为8123。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install polipo</span><br></pre></td></tr></table></figure><p>安装完成后，修改配置文件/etc/polipo/config</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">socksParentProcy = "localhost:9050" #tor服务本地端口为9050</span><br><span class="line">socksProxyType = socks5</span><br></pre></td></tr></table></figure><h4 id="安装tor"><a href="#安装tor" class="headerlink" title="安装tor"></a>安装tor</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install tor</span><br></pre></td></tr></table></figure><p>安装完成后，修改配置文件/etc/tor/torrc，添加以下内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SOCKS5Proxy 127.0.0.1:1080 #shadowsocks本地服务端口为1080</span><br></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>&emsp;&emsp;完成上述操作后，开启polipo、tor和shadowsocks。如果我们希望在chrome浏览器中实现网络匿名，可以通过添加tor代理来实现。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代理协议：socks5    代理服务器：127.0.0.1    代理端口：9050</span><br></pre></td></tr></table></figure><p>如果我们希望在命令行中实现网络匿名，可以通过polipo代理来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_proxy=http://localhost:8123 "需要执行的操作“</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://chaoge123456.github.io/Tor%E5%8C%BF%E5%90%8D%E7%BD%91%E7%BB%9C.html/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Hadoop分布式集群搭建</title>
      <link>https://chaoge123456.github.io/Hadoop%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA.html/</link>
      <guid>https://chaoge123456.github.io/Hadoop%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA.html/</guid>
      <pubDate>Thu, 22 Nov 2018 01:29:17 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;：Hadoop，是一个分布式系统基础架构，由Apache基金会开发。用户可以在不了解分布式底层细节的情况下，开发分布式程序。充分利用集群的威力高速运算和存储。简单地说来，Hadoop是一个可以更容易开发和运行处理大规模数据的软件平台。该
        
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>摘要</strong>：Hadoop，是一个分布式系统基础架构，由Apache基金会开发。用户可以在不了解分布式底层细节的情况下，开发分布式程序。充分利用集群的威力高速运算和存储。简单地说来，Hadoop是一个可以更容易开发和运行处理大规模数据的软件平台。该平台使用的是面向对象编程语言Java实现的，具有良好的可移植性。本文将介绍Hadoop相关的技术框架以及搭建Hadoop平台的详细过程。</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/hadoop/hadoop1.png" alt="avatar"></p><h2 id="文章概览"><a href="#文章概览" class="headerlink" title="文章概览"></a>文章概览</h2><ul><li>Hadoop简介<ul><li>Hadoop体系结构</li><li>HDFS分布式文件系统</li><li>MapReduce编程模型</li></ul></li><li>Hadoop平台搭建</li></ul><h3 id="Hadoop简介"><a href="#Hadoop简介" class="headerlink" title="Hadoop简介"></a>Hadoop简介</h3><h4 id="Hadoop体系结构"><a href="#Hadoop体系结构" class="headerlink" title="Hadoop体系结构"></a>Hadoop体系结构</h4><p><img src="https://i.ytimg.com/vi/f6UmOlD7NkA/maxresdefault.jpg" alt="avatar"></p><h4 id="HDFS分布式文件系统"><a href="#HDFS分布式文件系统" class="headerlink" title="HDFS分布式文件系统"></a>HDFS分布式文件系统</h4><p>&emsp;&emsp;在正式讨论HDFS分布式文件系统之前，我们首先了解一下什么是文件系统。文件系统实际上可以看作是一个用户与底层数据交互的一个接口，对于底层数据而言它定义了数据的存储和组织方式，同时也提供了存储空间的管理功能；而对于用户而言它使用文件和树形目录的抽象逻辑概念代替了存储设备中块的概念，用户使用文件系统来操作数据不必关心数据实际保存在硬盘（或者光盘）的地址为多少的数据块上，只需要记住这个文件的所属目录和文件名（关于文件系统更详细的介绍参见<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">维基百科</a>和<a href="https://linux.cn/article-8887-1.html" target="_blank" rel="noopener">这篇博客</a>)。传统文件系统适用于存储容量小等一些没有特殊要求的应用场景。</p><p>&emsp;&emsp;但是随着信息技术的不断发展，人们可以获取的数据成指数倍的增长，单纯通过增加硬盘个数来扩展计算机文件系统的存储容量的方式，在容量大小、容量增长速度、数据备份、数据安全等方面的表现都差强人意。为了满足这些特殊应用场景的需求，分布式文件系统应运而生。分布式文件系统可以有效解决数据的存储和管理难题：将固定于某个地点的某个文件系统，扩展到任意多个地点/多个文件系统，众多的节点组成一个文件系统网络。每个节点可以分布在不同的地点，通过网络进行节点间的通信和数据传输。人们在使用分布式文件系统时，无需关心数据是存储在哪个节点上、或者是从哪个节点从获取的，只需要像使用本地文件系统一样管理和存储文件系统中的数据（我们需要知道的是在分布式文件系统的每个数据结点上，数据的存储方式是建立在传统文件系统的基础上的，所谓分布式文件系统它提供的是数据宏观上的存储和管理方式）。</p><p>&emsp;&emsp;HDFS是分布式文件系统的一种，它采用master/slave架构，一个HDFS集群是由一个Namenode和一定数目的Datanodes组成。它可以处理超大规模的数据，并且提供了良好的容错机制，下图是HDFS的基本结构。</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/hadoop/HDFS.png" alt="avatar"></p><ul><li><strong>NameNode:</strong> 可以看作是分布式文件系统中的管理者，主要负责管理文件系统的命名空间、集群配置信息和存储块的复制等，NameNode会将文件系统的Meta-data存储到内存中，这些信息主要包括了文件信息、每一个文件对应的文件块的信息和每一个文件块在DataNode的信息等。</li><li><strong>Datanode:</strong> DataNode是文件存储的基本单元，他将Block存储在本地文件系统中，保存了Block的meta-data，同时周期性的将所有存在的Block信息发送给NameNode。slave存储实际的数据块，执行数据块的读写。</li><li><strong>Client:</strong> 文件切分与NameNode的交互，获取文件位置信息；与DataNode交互，读取或者写入数据；管理HDFS；访问HDFS。</li></ul><h5 id="HDFS读取数据流程"><a href="#HDFS读取数据流程" class="headerlink" title="HDFS读取数据流程"></a>HDFS读取数据流程</h5><p>客户端将要读取的文件路径发送给Namenode，Namenode获取文件的元信息（主要是block的存放位置信息）返回给客户端，客户端根据返回的信息找到相应Datanode逐个获取文件的block并在客户端本地进行数据追加合并从而获得整个文件</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/hadoop/HDFS_Read.png" alt="avatar"></p><h5 id="HDFS写数据流程"><a href="#HDFS写数据流程" class="headerlink" title="HDFS写数据流程"></a>HDFS写数据流程</h5><p>客户端要向HDFS写数据，首先要跟Namenode通信以确认可以写文件并获得接收文件block的Datanode，然后，客户端按顺序将文件逐个block传递给相应Datanode，并由接收到block的Datanode负责向其他Datanode复制block的副本。</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/hadoop/HDFS_Write.png" alt="avatar"></p><h4 id="MapReduce编程模型"><a href="#MapReduce编程模型" class="headerlink" title="MapReduce编程模型"></a>MapReduce编程模型</h4><p>&emsp;&emsp;MapReduce的诞生也是由于对大规模数据处理的需求。在大型的互联网公司，比如说Google、亚马逊等，在他们的平台上每天都会产生大量的数据，单个的处理器不可能在有限的时间内完成计算。根据多线程和并行计算的启发，我们可以将这些计算分布在成百上千的的机器上，这些机器集群就可以看作硬件资源池，将并行的任务拆分，然后交由每一个空闲机器资源去处理，能够极大地提高计算效率。但是由此而来引发的问题是在这个分布式计算系统中应该如何合理的处理并行计算？如何分发数据？如何处理错误？为了避免对这些问题的考虑，我们希望获得这样一个抽象模型，在这个模型中我们只需要关注我们希望执行的任务，而不必关心并行计算、容错、数据分布、负载均衡等复杂的细节，MapReduce就是这样一个抽象模型。</p><p>&emsp;&emsp;MapReduce 是一个编程模型，也是一个处理和生成超大数据集的算法模型的相关实现。用户首先创建一 个 Map 函数处理一个基于 key/value pair 的数据集合， 输出中间的基于 key/value pair 的数据集合； 然后再创建 一个 Reduce 函数用来合并所有的具有相同中间 key 值的中间 value 值。MapReduce 架构的程序能够在大量的普通配置的计算机上实现并行化处理。这个系统在运行时只关心： 如何分割输入数据，在大量计算机组成的集群上的调度，集群中计算机的错误处理，管理集群中计算机之间 必要的通信。采用 MapReduce 架构可以使那些没有并行计算和分布式处理系统开发经验的程序员有效利用分布式系统的丰富资源。</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/hadoop/MapReduce.jpg" alt="avatar"></p><h5 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h5><ul><li>用户程序首先调用的 MapReduce 库将输入文件分成 M 个数据片度，每个数据片段的大小一般从 16MB 到 64MB(可以通过可选的参数来控制每个数据片段的大小)。然后用户程序在机群中创建大量 的程序副本。</li><li>这些程序副本中的有一个特殊的程序–master。副本中其它的程序都是 worker 程序，由 master 分配 任务。有 M 个 Map 任务和 R 个 Reduce 任务将被分配，master 将一个 Map 任务或 Reduce 任务分配 给一个空闲的 worker。 </li><li>被分配了 map 任务的 worker 程序读取相关的输入数据片段，从输入的数据片段中解析出 key/value pair，然后把 key/value pair 传递给用户自定义的 Map 函数，由 Map 函数生成并输出的中间 key/value pair，并缓存在内存中。</li><li>缓存中的 key/value  pair 通过分区函数分成 R 个区域，之后周期性的写入到本地磁盘上。缓存的 key/value  pair 在本地磁盘上的存储位置将被回传给 master，由 master 负责把这些存储位置再传送给 Reduce worker</li><li>当 Reduce worker 程序接收到 master 程序发来的数据存储位置信息后， 使用 RPC 从 Map worker 所在的磁盘上读取这些缓存数据。当 Reduce worker 读取了所有的中间数据后，通过对 key 进行排序 后使得具有相同 key 值的数据聚合在一起。由于许多不同的 key 值会映射到相同的 Reduce 任务上， 因此必须进行排序。如果中间数据太大无法在内存中完成排序，那么就要在外部进行排序。</li><li>Reduce worker 程序遍历排序后的中间数据， 对于每一个唯一的中间 key 值， Reduce worker 程序将这 个 key 值和它相关的中间 value 值的集合传递给用户自定义的 Reduce 函数。Reduce 函数的输出被追加到所属分区的输出文件。</li><li>当所有的 Map 和 Reduce 任务都完成之后，master 唤醒用户程序。在这个时候，在用户程序里对 MapReduce 调用才返回。</li></ul><h3 id="Hadoop平台搭建"><a href="#Hadoop平台搭建" class="headerlink" title="Hadoop平台搭建"></a>Hadoop平台搭建</h3><p>&emsp;&emsp;Hadoop有三种安装模式：本地模式安装、伪分布模式安装和完全分布式安装。本文主要介绍Hadoop完全分布式安装，真实环境下都是以这种方式部署（1台Master，2台Slave）。</p><h5 id="部署环境"><a href="#部署环境" class="headerlink" title="部署环境"></a>部署环境</h5><ul><li>Hadoop2.8.5</li><li>VMware14</li><li>ubuntu16.04</li><li>jdk11.01</li></ul><h5 id="第一步：安装ubuntu"><a href="#第一步：安装ubuntu" class="headerlink" title="第一步：安装ubuntu"></a>第一步：安装ubuntu</h5><p>虚拟机的安装教程网上很多，这里不在赘述，注意这里只需要安装一个虚拟机，虚拟机的网络连接方式为NAT。</p><h5 id="第二步：在虚拟机中安装jdk"><a href="#第二步：在虚拟机中安装jdk" class="headerlink" title="第二步：在虚拟机中安装jdk"></a>第二步：在虚拟机中安装jdk</h5><p>我使用的jdk版本是jdk11.01，建议使用jdk1.8。jdk安装完成后需要配置环境变量，jdk的默认安装路径是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/lib/jvm/jdk-11.01</span><br></pre></td></tr></table></figure><p>编辑用户目录下.bashrc文件，在文件末尾添加</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/lib/jvm/jdk-11.01  </span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre  </span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib  </span><br><span class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure><h5 id="第三步：克隆虚拟机"><a href="#第三步：克隆虚拟机" class="headerlink" title="第三步：克隆虚拟机"></a>第三步：克隆虚拟机</h5><p>利用VMware的克隆功能，克隆两个虚拟机</p><h5 id="第四步：修改hostname文件"><a href="#第四步：修改hostname文件" class="headerlink" title="第四步：修改hostname文件"></a>第四步：修改hostname文件</h5><p>现在我们得到三个一模一样的虚拟机，我们选取其中一个虚拟机为Master，其余两个虚拟机分别为Slave。修改Master主机的hostname为Master，两个Slave的hostname分别为Slave1和Slave2，hosts文件的路径为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/hostname</span><br></pre></td></tr></table></figure><h5 id="第五步：配置静态IP"><a href="#第五步：配置静态IP" class="headerlink" title="第五步：配置静态IP"></a>第五步：配置静态IP</h5><p>分别查看三台主机的IP地址，然后修改hosts文件，将三台主机的hostname以及对于的IP添加到hosts文件中，hosts文件路径为，三台主机都要进行同样的操作。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/etc/</span>hosts</span><br></pre></td></tr></table></figure><p>在我的系统中，三台主机的IP如图所示</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/hadoop/hosts.PNG" alt="avatar"></p><h5 id="第六步：建立Hadoop运行账号"><a href="#第六步：建立Hadoop运行账号" class="headerlink" title="第六步：建立Hadoop运行账号"></a>第六步：建立Hadoop运行账号</h5><p>在三台主机上都要建立一个hadoop用户组，并在用户组中添加名为hduser的用户,具体操作如下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd hadoop   #建立hadoop用户组</span><br><span class="line">sudo useradd -s /bin/bash -d /home/hduser -m hduser -g hadoop #添加hduser，指定用户目录</span><br><span class="line">sudo passwd hduser   #修改hduser用户密码</span><br><span class="line">sudo adduser hduser sudo  #赋予hduser管理员权限</span><br><span class="line">su hduser  #切换到hduser用户</span><br></pre></td></tr></table></figure><h5 id="第七步：配置ssh免密登录"><a href="#第七步：配置ssh免密登录" class="headerlink" title="第七步：配置ssh免密登录"></a>第七步：配置ssh免密登录</h5><p>ubuntu默认安装了ssh客户端，但没有安装ssh服务器，配置之前先在三台主机中安装ssh-server</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install</span><br></pre></td></tr></table></figure><p>接着在Master主机中执行如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -P '' -f ~/.ssh/id_rsa  #生成ssh公钥和私钥</span><br><span class="line">cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys  #添加公钥到已认证的key中</span><br></pre></td></tr></table></figure><p>在两台Slave主机中的用户目录下新建.ssh文件夹，然后将Master中的id_rsa.pub文件复制到两台Slave主机的.ssh文件夹下，执行如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys  #添加公钥到已认证的key中</span><br></pre></td></tr></table></figure><p>最后验证是否可以通过Master免密登录两台Slave主机。</p><h5 id="第八步-下载并解压Hadoop"><a href="#第八步-下载并解压Hadoop" class="headerlink" title="第八步:下载并解压Hadoop"></a>第八步:下载并解压Hadoop</h5><p>三台主机都要进行该操作，在用户目录下建立名为hadoop2.8.5的目录，将文件解压到该目录下。</p><h5 id="第九步：修改配置文件"><a href="#第九步：修改配置文件" class="headerlink" title="第九步：修改配置文件"></a>第九步：修改配置文件</h5><p>三台主机都要进行该操作</p><ul><li><p>修改hadoop-env.sh文件,添加JAVA_HOME。（~/hadoop/hadoop2.8.5/etc/hadoop/hadoop-env.sh）</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/hadoop/1.PNG" alt="avatar"></p></li><li><p>修改core-site.cml文件，添加如下内容。（~/hadoop/hadoop2.8.5/etc/hadoop/core-site.cml)</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/hadoop/2.PNG" alt="avatar"></p></li><li><p>修改hdfs-site.xml文件，添加如下内容。（~/hadoop/hadoop2.8.5/etc/hadoop/hdfs-site.xml）</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/hadoop/3.PNG" alt="avatar"></p></li><li><p>修改mapred-site.xml.template文件，添加如下内容。（~/hadoop/hadoop2.8.5/etc/hadoop/mapred-site.xml.template）</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/hadoop/4.PNG" alt="avatar"></p></li><li><p>修改slaves文件，将两台Slave主机名添加进去即可。（~/hadoop/hadoop2.8.5/etc/hadoop/slaves）</p></li><li><p>修改/etc/profile文件，添加如下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/lib/jvm/jdk-11.0.1</span><br><span class="line">export HADOOP_INSTALL=/home/hduser/hadoop/hadoop-2.8.5</span><br><span class="line">export PATH=$PATH:$&#123;HADOOP_INSTALL&#125;/bin:$&#123;HADOOP_INSTALL&#125;/sbin:$&#123;JAVA_HOME&#125;/bin</span><br></pre></td></tr></table></figure><p>然后执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p>检查hadoop是否安装成功</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/hadoop/5.PNG" alt="avatar"></p></li></ul><h5 id="第十步：格式化namenode，并启动集群"><a href="#第十步：格式化namenode，并启动集群" class="headerlink" title="第十步：格式化namenode，并启动集群"></a>第十步：格式化namenode，并启动集群</h5><p>在Master主机中执行以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hadoop namenode -format  #格式化namenode</span><br><span class="line">start-all.ssh  #启动集群</span><br></pre></td></tr></table></figure><p>在ubuntu地址栏中输入http:Master:50070,可以看到Slave结点的相关信息</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/hadoop/hadoop.png" alt="avator"></p>]]></content:encoded>
      
      <comments>https://chaoge123456.github.io/Hadoop%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA.html/#disqus_thread</comments>
    </item>
    
    <item>
      <title>HITB安全峰会之旅.md</title>
      <link>https://chaoge123456.github.io/HITB%E5%AE%89%E5%85%A8%E5%B3%B0%E4%BC%9A%E4%B9%8B%E6%97%85.html/</link>
      <guid>https://chaoge123456.github.io/HITB%E5%AE%89%E5%85%A8%E5%B3%B0%E4%BC%9A%E4%B9%8B%E6%97%85.html/</guid>
      <pubDate>Sun, 04 Nov 2018 14:33:12 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;2018年10月25日，一次偶然的机会在阿里安全响应中心看到了一则新闻-HITB首次走进中国。当时也并没有太在意，因为本身对HITB没有什么印象，在安全领域我关注的会议并不多，比较了解的是BLACKHAT和DEFCON。正好前几天去合
        
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>摘要：</strong>2018年10月25日，一次偶然的机会在阿里安全响应中心看到了一则新闻-HITB首次走进中国。当时也并没有太在意，因为本身对HITB没有什么印象，在安全领域我关注的会议并不多，比较了解的是BLACKHAT和DEFCON。正好前几天去合肥参加了科大讯飞的全球开发者大会，回来之后其实挺失望的（从学术界到产业界都在极力鼓吹“AI”所蕴含的价值，但是却始终看不到实质性的产品和突破，而且很大程度忽视了“AI”所带来的负面影响），当看到这则新闻的时候有感而发，在留言处写下了一点个人的感受。没想到的是，第二天居然收到通知说我的留言被小编抽中了，作为奖励我也免费获得了一张HITB安全峰会的门票。突如其来的惊喜让我有点措手不及，我赶紧上网查了一下关于HITB峰会的相关信息，这才对HITB有了一些了解。作为欧洲三大顶级安全会议之一，HITB一直拥有良好的口碑和技术氛围，我觉得这对我来说是一次很好的机会。之后，我也获得了导师的支持，于是2018年10月30日，我踏上了这次难忘的HITB安全峰会之旅。</p>]]></content:encoded>
      
      <comments>https://chaoge123456.github.io/HITB%E5%AE%89%E5%85%A8%E5%B3%B0%E4%BC%9A%E4%B9%8B%E6%97%85.html/#disqus_thread</comments>
    </item>
    
    <item>
      <title>维吉尼亚加解密及唯密文破解</title>
      <link>https://chaoge123456.github.io/%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E5%8A%A0%E8%A7%A3%E5%AF%86%E5%8F%8A%E5%94%AF%E5%AF%86%E6%96%87%E7%A0%B4%E8%A7%A3.html/</link>
      <guid>https://chaoge123456.github.io/%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E5%8A%A0%E8%A7%A3%E5%AF%86%E5%8F%8A%E5%94%AF%E5%AF%86%E6%96%87%E7%A0%B4%E8%A7%A3.html/</guid>
      <pubDate>Wed, 17 Oct 2018 02:10:22 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt; 古典密码体制主要通过字符间的置换和代换来实现，常见的置换密码包括列置换密码和周期置换密码，而常见的代换密码包括单表代换密码和多表代换密码，本文所讨论的维吉尼亚算法是属于多表代换密码的一种。多表代换密码是以一系列代换表依次对明文消息的字
        
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>摘要</strong> 古典密码体制主要通过字符间的置换和代换来实现，常见的置换密码包括列置换密码和周期置换密码，而常见的代换密码包括单表代换密码和多表代换密码，本文所讨论的维吉尼亚算法是属于多表代换密码的一种。多表代换密码是以一系列代换表依次对明文消息的字母序列进行代换的加密方法，即明文消息中出现的同一个字母，在加密时不是完全被同一固定的字母代换，而是根据其出现的位置次序用不同的字母代换。如果代换表序列是非周期的无限序列，则相应的密码称为非周期多表代换密码，这类密码对每个明文都采用了不同的代换表进行加密，故称为一次一密密码，它是理论上不可破译的密码体制。但实际应用中经常采用的是周期多表代换密码，它通常使用有限个代换表，代换表被重复使用以完成消息的加密。作为多表代换密码的典型代表，维吉尼亚密码算法蕴含着丰富的古典密码设计思想，本文将深入探讨维吉尼亚算法的加解密过程实现，以及利用统计分析的方法进行唯密文攻击。</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/verify/crypt.jpg" alt="avatar"></p><h2 id="文章概览"><a href="#文章概览" class="headerlink" title="文章概览"></a>文章概览</h2><ul><li>维吉尼亚算法简介</li><li>加密算法实现<ul><li>编码方式</li><li>对明文进行处理</li><li>加密过程</li></ul></li><li>解密算法实现</li><li>唯密文攻击<ul><li>确定密钥长度</li><li>确定密钥</li><li>恢复明文</li></ul></li></ul><h3 id="维吉尼亚算法简介"><a href="#维吉尼亚算法简介" class="headerlink" title="维吉尼亚算法简介"></a><a href="https://zh.wikipedia.org/wiki/%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E5%AF%86%E7%A0%81" target="_blank" rel="noopener">维吉尼亚算法简介</a></h3><h3 id="加密算法实现"><a href="#加密算法实现" class="headerlink" title="加密算法实现"></a>加密算法实现</h3><p>&emsp;&emsp;实现加密算法的大致流程是：首先我们需要确定编码方式，本文采用的编码方式是[a-z]对应[0-25]；接着进行加密算法前需要对明文字符串进行处理，删除非字母字符，将大写字符统一转换为小写字母；最后选定密钥对密文中的逐个字符进行加密（即代换操作），生成最后的密文。</p><h4 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h4><p>&emsp;&emsp;本文的字母编码方式由列表s确定，s中每个元素的索引即对应该元素的数字编码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>,<span class="string">'g'</span>,<span class="string">'h'</span>,<span class="string">'i'</span>,<span class="string">'j'</span>,<span class="string">'k'</span>,<span class="string">'l'</span>,<span class="string">'m'</span>,<span class="string">'n'</span>,<span class="string">'o'</span>,<span class="string">'p'</span>,<span class="string">'q'</span>,<span class="string">'r'</span>,<span class="string">'s'</span>,<span class="string">'t'</span>,<span class="string">'u'</span>,<span class="string">'v'</span>,<span class="string">'w'</span>,<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>]</span><br></pre></td></tr></table></figure><h4 id="对明文进行处理"><a href="#对明文进行处理" class="headerlink" title="对明文进行处理"></a>对明文进行处理</h4><p>&emsp;&emsp;对明文进行处理的目的是去除明文中非字母的字符，并将大写字母统一转换为小写字母。转换大小写我们可以使用python字符串内置的lower()函数，稍微有点棘手的是前者，因为在这里需要考虑到一些效率的问题还有如何对后续操作进行优化的问题，比如说:</p><ul><li>读取文件中的明文时我们可以采用read()，readline()，readlines()这三个函数，那我们到底采用哪一个呢？（这三个函数的对比可以参考<a href="https://blog.csdn.net/quiet_girl/article/details/80113591" target="_blank" rel="noopener">这篇博客</a>)</li><li>采用不同读取明文的函数，导致读取结果也不尽相同，有列表形式也有字符串形式，到底哪种形式对后续的操作更有好处</li><li>去掉读取后的明文中的非字母字符应采用何种方式？（逐个字符判断或者正则表达式）</li></ul><p>本文根据文本的实际情况，采用的处理方式如下所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pretreatment</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    pretreatment函数的主要作用是对明文进行预处理，去除非字母字符和转换大小写</span></span><br><span class="line"><span class="string">    :return: 经过预处理的明文字符串</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"plain.txt"</span>,<span class="string">"r"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        wen = f.read()</span><br><span class="line">    pattern = re.compile(<span class="string">'[\n]|\d|\W'</span>)</span><br><span class="line">    plain_1 = re.sub(pattern,<span class="string">''</span>,wen).lower()</span><br><span class="line">    <span class="keyword">return</span> plain_1</span><br></pre></td></tr></table></figure><h4 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h4><p>&emsp;&emsp;维吉尼亚算法的加密过程比较简单，基本思想是利用密钥循环对明文字符进行代换操作，进行代换前将相应的明文字符和密钥字符转化为对应的数字编码，然后相加对26取余即得到对应的密文字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(key)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    encrypt函数的主要作用是进行加密</span></span><br><span class="line"><span class="string">    :param key: 密钥</span></span><br><span class="line"><span class="string">    :return: 密文字符串</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    wen = pretreatment()</span><br><span class="line">    num_key = key_to_num(key)</span><br><span class="line">    ciphertext = <span class="string">''</span></span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> wen:</span><br><span class="line">        <span class="keyword">if</span> k == len(num_key):</span><br><span class="line">            k = <span class="number">0</span></span><br><span class="line">        cipher = change(w,num_key[k])</span><br><span class="line">        cipher = num_to_char(cipher)</span><br><span class="line">        ciphertext = ciphertext + cipher</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">    wirte_txt(ciphertext,<span class="string">'crypt.txt'</span>)</span><br><span class="line">    <span class="keyword">return</span> ciphertext</span><br></pre></td></tr></table></figure><h3 id="解密算法实现"><a href="#解密算法实现" class="headerlink" title="解密算法实现"></a>解密算法实现</h3><p>&emsp;&emsp;解密算法是加密算法的逆过程，进行的代换操作是将密文字符的数字编码减去密钥字符的数字编码，如果相减的结果小于0，则令结果加上26，在转换为对应编码的字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">de_change</span><span class="params">(ch,num)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    de_change函数的作用是根据密文字符和密钥还原明文字符</span></span><br><span class="line"><span class="string">    :param ch: 密文字符</span></span><br><span class="line"><span class="string">    :param num: 密钥编码</span></span><br><span class="line"><span class="string">    :return: 明文字符</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    ch_num = char_to_num(ch)</span><br><span class="line">    result = ch_num - num</span><br><span class="line">    <span class="keyword">if</span> result &lt; <span class="number">0</span>:</span><br><span class="line">        result = <span class="number">26</span> + result</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(key)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    decryption函数的主要作用是将密文解密成明文</span></span><br><span class="line"><span class="string">    :param key: 密钥</span></span><br><span class="line"><span class="string">    :return: 明文</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'crypt.txt'</span>,<span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        ciphertext = f.read()</span><br><span class="line">    num_key = key_to_num(key)</span><br><span class="line">    wen = <span class="string">''</span></span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> ciphertext:</span><br><span class="line">        <span class="keyword">if</span> k == len(num_key):</span><br><span class="line">            k = <span class="number">0</span></span><br><span class="line">        w = de_change(c,num_key[k])</span><br><span class="line">        w = num_to_char(w)</span><br><span class="line">        wen = wen + w</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">    wirte_txt(wen,<span class="string">'result.txt'</span>)</span><br><span class="line">    <span class="keyword">return</span> wen</span><br></pre></td></tr></table></figure><h3 id="唯密文攻击"><a href="#唯密文攻击" class="headerlink" title="唯密文攻击"></a>唯密文攻击</h3><p>&emsp;&emsp;某种语言中各个字符出现的频率不一样而表现出一定的统计规律，而这种统计规律可能在密文中重现，所以我们可以通过统计分析的手段进行一些推测和验证过程来实现对密文的分析。在英文字母中各个字母出现的频率如下所示，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#编码规则</span></span><br><span class="line">s = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>,<span class="string">'g'</span>,<span class="string">'h'</span>,<span class="string">'i'</span>,<span class="string">'j'</span>,<span class="string">'k'</span>,<span class="string">'l'</span>,<span class="string">'m'</span>,<span class="string">'n'</span>,<span class="string">'o'</span>,<span class="string">'p'</span>,<span class="string">'q'</span>,<span class="string">'r'</span>,<span class="string">'s'</span>,<span class="string">'t'</span>,<span class="string">'u'</span>,<span class="string">'v'</span>,<span class="string">'w'</span>,<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>]</span><br><span class="line"><span class="comment">#字母出现频率</span></span><br><span class="line">frequency = [<span class="number">0.082</span>,<span class="number">0.015</span>,<span class="number">0.028</span>,<span class="number">0.043</span>,<span class="number">0.127</span>,<span class="number">0.022</span>,<span class="number">0.02</span>,<span class="number">0.061</span>,<span class="number">0.07</span>,<span class="number">0.002</span>,<span class="number">0.008</span>,<span class="number">0.04</span>,<span class="number">0.024</span>,<span class="number">0.06</span>,<span class="number">0.075</span>,<span class="number">0.019</span>,<span class="number">0.001</span>,<span class="number">0.06</span>,<span class="number">0.063</span>,<span class="number">0.091</span>,<span class="number">0.028</span>,<span class="number">0.01</span>,<span class="number">0.023</span>,<span class="number">0.001</span>,<span class="number">0.02</span>,<span class="number">0.001</span>]</span><br></pre></td></tr></table></figure><p>对于维吉尼亚密码体制来说，我们可以通过统计分析的方法对其密文进行分析，从而获取明文信息。基于维吉尼亚密码体制的唯密文攻击的破解主要包含三个步骤：</p><ul><li>确定密钥长度，常用的方法包括卡西斯基测试法和重合指数法，本文将采用后者进行分析</li><li>确定密钥，常用的方法是拟重合指数法</li><li>根据密文和密钥恢复明文</li></ul><h4 id="确定密钥长度"><a href="#确定密钥长度" class="headerlink" title="确定密钥长度"></a>确定密钥长度</h4><p>&emsp;&emsp;本文采用重合指数法猜解密钥长度，关于重合指数法的具体解释可以参照《现代密码学教程》或者<a href="https://zh.wikipedia.org/wiki/%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E5%AF%86%E7%A0%81" target="_blank" rel="noopener">维基百科</a>，本文主要讲解猜解密钥长度的实现过程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">guess_len_key</span><span class="params">(crypt)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    guess_len_key函数的主要作用是通过密文猜解密钥长度</span></span><br><span class="line"><span class="string">    :param crypt: 密文</span></span><br><span class="line"><span class="string">    :return: 密钥长度以及划为的子串</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    l = <span class="number">1</span></span><br><span class="line">    d = &#123;&#125;</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        print(<span class="string">"****************************假设密钥长度        为%s***********************************"</span> % l)</span><br><span class="line">        sum_index = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(crypt)):</span><br><span class="line">            n = i % l</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                d[n] = <span class="string">''</span></span><br><span class="line">            d[n] += crypt[i]</span><br><span class="line">        sum_index = sum(coincidence_index(d[j]) <span class="keyword">for</span> j <span class="keyword">in</span> range(l)) / l</span><br><span class="line">        <span class="keyword">if</span> sum_index &gt;= <span class="number">0.06</span> <span class="keyword">and</span> sum_index &lt;= <span class="number">0.07</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">            d = &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> l,d</span><br></pre></td></tr></table></figure><p>该算法的主要思想是将密文划分为l个子串，子串存放在字典d中。分别计算l个子串的重合指数，然后计算l个重合指数的平均数，如果该平均数位于[0.06,0.07]这个区间内，则说明密钥长度为l，返回密钥长度以及划分的l个子串；如果得到的平均数不在[0.06,0.07]这个区间内，则l自增，d初始化，进行下一轮猜解。</p><h4 id="确定密钥"><a href="#确定密钥" class="headerlink" title="确定密钥"></a>确定密钥</h4><p>&emsp;&emsp;确定密钥长度大致过程是：利用之前得到的l个子串，对每个子串都进行移位操作。假设现在对第i个子串进行移位操作（子串的每个字符移动相同的位数，最坏情况下对同一个子串需要进行26次移位操作），移动的位数为k,（k在[0-25]区间内，也就对应了[a-z]）。每进行一次移位操作，就对该子串计算一次拟重合指数，如果该拟重合指数位于[0.06,0.07]这个区间内，则说明此时移动的位数对应的s列表中的字符即为该子串的密钥；否则，继续进行下一次移位操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_key</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    cracker函数的主要作用是破解密钥</span></span><br><span class="line"><span class="string">    :return: 返回密钥</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"crypt.txt"</span>,<span class="string">"r"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        crypt = f.read()</span><br><span class="line">    len_key,d = guess_len_key(crypt)</span><br><span class="line">    key = <span class="string">''</span></span><br><span class="line">    print(<span class="string">"\n-------------------------------------"</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"|       经计算可知，密钥长度为%s         |"</span> % len_key)</span><br><span class="line">    print(<span class="string">"-------------------------------------\n"</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len_key):</span><br><span class="line">        substring = d[i]</span><br><span class="line">        print(<span class="string">"当前字串为："</span>,d[i])</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">26</span>):</span><br><span class="line">            dex = quasi_index(substring, n)</span><br><span class="line">            print(<span class="string">"假设子串移动&#123;&#125;,拟重合指数为&#123;:.4f&#125;"</span>.format(s[n],dex))</span><br><span class="line">            <span class="keyword">if</span> dex &gt;= <span class="number">0.06</span> <span class="keyword">and</span> dex &lt;= <span class="number">0.07</span>:</span><br><span class="line">                key += s[n]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    print(<span class="string">"******************************破解的最终密钥为%s*********************************"</span> % key)</span><br></pre></td></tr></table></figure><h4 id="恢复明文"><a href="#恢复明文" class="headerlink" title="恢复明文"></a>恢复明文</h4><p>&emsp;&emsp;恢复明文的过程与解密过程类似，这里不在详述。</p><h3 id="系统运行演示"><a href="#系统运行演示" class="headerlink" title="系统运行演示"></a>系统运行演示</h3><h4 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h4><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/verify/jiami.PNG" alt="avatar"></p><h4 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h4><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/verify/jiemi.PNG" alt="avatar"></p><h4 id="猜解密钥长度"><a href="#猜解密钥长度" class="headerlink" title="猜解密钥长度"></a>猜解密钥长度</h4><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/verify/keylen.PNG" alt="avatar"></p><h4 id="猜解密钥"><a href="#猜解密钥" class="headerlink" title="猜解密钥"></a>猜解密钥</h4><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/verify/nichonghe.PNG" alt="avatar"></p>]]></content:encoded>
      
      <comments>https://chaoge123456.github.io/%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E5%8A%A0%E8%A7%A3%E5%AF%86%E5%8F%8A%E5%94%AF%E5%AF%86%E6%96%87%E7%A0%B4%E8%A7%A3.html/#disqus_thread</comments>
    </item>
    
    <item>
      <title>raspberry入门配置</title>
      <link>https://chaoge123456.github.io/raspberry%E5%85%A5%E9%97%A8%E9%85%8D%E7%BD%AE.html/</link>
      <guid>https://chaoge123456.github.io/raspberry%E5%85%A5%E9%97%A8%E9%85%8D%E7%BD%AE.html/</guid>
      <pubDate>Sat, 22 Sep 2018 12:53:38 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt; 最近准备在树莓派上搭建一个智能家居系统，更新系统的过程中不知道什么原因导致系统崩了，我的心顿时凉了半截。查阅了很多资料，没找到解决方法，只能重装系统（基于stretch版本）了。虽然之前的系统也是自己一步步配置的，但是这次重新配置的过
        
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>摘要</strong> 最近准备在树莓派上搭建一个智能家居系统，更新系统的过程中不知道什么原因导致系统崩了，我的心顿时凉了半截。查阅了很多资料，没找到解决方法，只能重装系统（基于stretch版本）了。虽然之前的系统也是自己一步步配置的，但是这次重新配置的过程中还是遇到了很多问题，在这里记录一下，希望能给小伙伴们一些启发。</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/raspberry/images.png" alt="avatar"></p><h2 id="文章概览"><a href="#文章概览" class="headerlink" title="文章概览"></a>文章概览</h2><ul><li>重新安装系统</li><li>连接树莓派</li><li>安装远程桌面服务</li><li>更新软件源</li><li>raspi-config</li><li>配置无线网络</li><li>配置静态IP</li><li>配置内网映射</li><li>安装zsh</li><li>python环境搭建</li></ul><h3 id="重新安装系统"><a href="#重新安装系统" class="headerlink" title="重新安装系统"></a>重新安装系统</h3><p>&emsp;&emsp;重新安装系统的过程我们需要用到：<a href="https://www.raspberrypi.org/downloads/" target="_blank" rel="noopener">系统镜像</a>、<a href="http://www.diskgenius.cn/" target="_blank" rel="noopener">DiskGenius</a>、<a href="#https://sourceforge.net/projects/win32diskimager/">Win32DiskImager</a>，DiskGenius的作用是格式化TF卡，Win32DiskImager的作用是将系统镜像写入TF卡，具体的操作过程可以参考<a href="https://www.jianshu.com/p/6af60049fdf1" target="_blank" rel="noopener">这篇博客</a>。</p><h3 id="连接树莓派"><a href="#连接树莓派" class="headerlink" title="连接树莓派"></a>连接树莓派</h3><p>&emsp;&emsp;对于如何连接树莓派，我在之前的博客中详细的讨论过，这里不再赘述，需要提醒大家的是只需要使用某一种方法连接树莓派即可。</p><h3 id="安装远程连接服务"><a href="#安装远程连接服务" class="headerlink" title="安装远程连接服务"></a>安装远程连接服务</h3><p>&emsp;&emsp;ssh连接是通过命令行对树莓派进行远程操作，而远程桌面是直接通过树莓派的GUI界面进行操作，操作简单，交互性好。xrdp是一个开源的远程桌面服务器，支持windows远程桌面连接，但是需要使用tightvncserver作为其基础服务，具体安装操作如下所示。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update #更新</span><br><span class="line">sudo apt-get install xrdp</span><br><span class="line">sudo apt-get install tightvncserver</span><br></pre></td></tr></table></figure><p>安装好以上两个服务以后。可以使用windows自带的远程连接工具连接到树莓派。</p><h3 id="更新软件源"><a href="#更新软件源" class="headerlink" title="更新软件源"></a>更新软件源</h3><p>&emsp;&emsp;在更新软件源的时候，大家注意查看自己的系统版本（推荐大家安装最新的系统版本），具体操作参见<a href="https://mirror.tuna.tsinghua.edu.cn/help/" target="_blank" rel="noopener">清华大学开源软件镜像站</a>。</p><h3 id="raspi-config"><a href="#raspi-config" class="headerlink" title="raspi-config"></a>raspi-config</h3><p>&emsp;&emsp;通过远程桌面连接到树莓派之后，系统会提示进行一些初始化配置，包括拓展内存、设置时区、语言等等，具体操作参见<a href="http://shumeipai.nxez.com/2013/09/07/raspi-config-configuration-raspberry-pie.html" target="_blank" rel="noopener">这篇博客</a>。</p><h3 id="配置无线网络"><a href="#配置无线网络" class="headerlink" title="配置无线网络"></a>配置无线网络</h3><p>&emsp;&emsp;配置无线网络有两种方式，一个是在图形化界面直接选择连接的ssid，输入密码即可，系统会保存该无线网络的相关信息到/etc/wpa_supplicant/wpa_supplicant.conf文件；另外一种方式是直接修改该配置文件，将无线网络配置信息添加到该文件中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">country=CN</span><br><span class="line">ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev</span><br><span class="line">update_config=1</span><br><span class="line"></span><br><span class="line">network=&#123;</span><br><span class="line">    ssid="***"</span><br><span class="line">    psk="***"</span><br><span class="line">    priority=1</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="配置静态IP"><a href="#配置静态IP" class="headerlink" title="配置静态IP"></a>配置静态IP</h3><p>&emsp;&emsp;由于每次树莓派连接路由器的时候，路由器会分配不同的IP地址，所以当我们连接树莓派的时候每次都要通过路由器查看树莓派的IP地址，这样比较麻烦，所以，我们需要给路由器指定静态的IP。修改/etc/dhcpcd.conf文件（一定要注意不是修改/etc/network/interfaces文件），在后面添加以下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface eth0 #有线</span><br><span class="line"> </span><br><span class="line">static ip_address=192.168.0.10/24</span><br><span class="line">static routers=192.168.0.1</span><br><span class="line">static domain_name_servers=192.168.0.1</span><br><span class="line"> </span><br><span class="line">interface wlan0 #无线连接</span><br><span class="line"> </span><br><span class="line">static ip_address=192.168.0.200/24</span><br><span class="line">static routers=192.168.0.1</span><br><span class="line">static domain_name_servers=192.168.0.1</span><br></pre></td></tr></table></figure><h3 id="配置内网映射"><a href="#配置内网映射" class="headerlink" title="配置内网映射"></a>配置内网映射</h3><p>&emsp;&emsp;如果想要从外网直接访问树莓派，那我们需要将树莓派的内网IP映射到公网当中，这里我们使用的映射工具是花生壳，具体操作参见<a href="http://service.oray.com/question/2680.html" target="_blank" rel="noopener">官方教程</a>。</p><h3 id="安装zsh"><a href="#安装zsh" class="headerlink" title="安装zsh"></a>安装zsh</h3><p>&emsp;&emsp;树莓派基于linux操作系统，其终端shell默认的是bash，而zsh是比bash更加强大的shell，而且更加美观，具体配置参见<a href="https://mlapp.cn/310.html" target="_blank" rel="noopener">这篇博客</a>。</p><h3 id="python环境搭建"><a href="#python环境搭建" class="headerlink" title="python环境搭建"></a>python环境搭建</h3><p>&emsp;&emsp;树莓派中内置了两个版本的python，python2.7和python3.5，系统默认版本为python2.7。在进行系统环境配置和相关依赖安装的过程中，一律使用系统默认版本即python2.7（如果切换至python3.5.会出现各种各样的问题）。在程序开发过程中如果需要使用python3.5，可以切换python环境，具体操作参见<a href="https://linux.cn/article-6970-1.html" target="_blank" rel="noopener">这篇博客</a>。</p>]]></content:encoded>
      
      <comments>https://chaoge123456.github.io/raspberry%E5%85%A5%E9%97%A8%E9%85%8D%E7%BD%AE.html/#disqus_thread</comments>
    </item>
    
    <item>
      <title>如何连接树莓派</title>
      <link>https://chaoge123456.github.io/%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5%E6%A0%91%E8%8E%93%E6%B4%BE.html/</link>
      <guid>https://chaoge123456.github.io/%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5%E6%A0%91%E8%8E%93%E6%B4%BE.html/</guid>
      <pubDate>Thu, 13 Sep 2018 12:08:02 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt; 早就听说了树莓派的大名，什么智能家居，智能机器人，无人机等等它都不在话下。我最近刚刚入手了一款树莓派3B+，想利用它来开发一个智能家居的控制系统。由于从来没有接触过相关的硬件，在配置过程中确实遇到了不少坑，在这里简单的记录一下，希望能
        
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>摘要</strong> 早就听说了树莓派的大名，什么智能家居，智能机器人，无人机等等它都不在话下。我最近刚刚入手了一款树莓派3B+，想利用它来开发一个智能家居的控制系统。由于从来没有接触过相关的硬件，在配置过程中确实遇到了不少坑，在这里简单的记录一下，希望能给读者一些启发。本文主要讲解如何连接树莓派的问题。</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/raspberry/shumei.jpg" alt="avatar"></p><h2 id="文章概览"><a href="#文章概览" class="headerlink" title="文章概览"></a>文章概览</h2><ul><li>基本配置</li><li>系统安装</li><li>连接树莓派<ul><li>有路由器和网线的情况下</li><li>有网线没有路由器的情况下</li><li>没有路由器没有网线的情况下</li></ul></li></ul><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p>&emsp;&emsp;想要玩树莓派，仅仅买一块主板是不够的，基本的配置包括：一块主板（大概225RMB）、一个读卡器（大概10RMB）、一根电源线（大概8RMB）、一张大于8G的内存卡（我买的是32G的，38RMB）、散热片（大概5RMB）和一个保护外壳（大概20RMB），推荐大家主板和配件分开买，这样比较划算。</p><h3 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h3><p>&emsp;&emsp;树莓派的安装过程比较简单，首先我们需要下载准备安装的系统镜像，在<a href="#https://www.raspberrypi.org/downloads/">树莓派官网</a>可以下载到相关的镜像文件，树莓派支持的系统很多，包括ubuntu、kail、win10等等。我选择的系统是树莓派官方推荐的RSAPBIAN，基于Debian，稳定兼容性好。然后我们需要下载一款工具：<a href="#http://sourceforge.net/projects/win32diskimager/files/latest/download">win32diskimager</a>，我们需要利用这款工具将树莓派的系统镜像写入内存卡。</p><p>&emsp;&emsp;准备工作完成后，我们通过读卡器将内存卡接入电脑，在利用win32diskmager工具将系统镜像写入内存卡（这个过程很简单，这里不再详细解释）。镜像写入完成之后，我们的系统就成功的安装到内存卡中。但是，有一个问题需要我们注意，镜像写入完成后系统会弹出一个对话框，大概的意思是：无法识别内存卡中的数据，是否要将内存卡格式化，这个时候大家一定选择否或者直接关闭对话框。因为系统写入完成之后，我们的主机只能读出内存卡中系统的boot分区（大概只有40多MB），内存卡中的其他分区我们的系统识别不出来，所以才会弹出这个对话框，一旦我们选择格式化，刚才安装的系统会被删除。如果有小伙伴不小心选择了格式化，那就只有重新安装系统了，大家可以参考<a href="#https://www.jianshu.com/p/6af60049fdf1">这篇博客</a>。</p><p>&emsp;&emsp;还有一个需要注意的问题是，树莓派默认没有开启ssh服务，所以之后我们如果需要通过ssh连接树莓派时，我们需要在刚刚写入系统的内存卡的boot文件夹下，建立一个文件名为ssh的空文件（无后缀名），这样在之后的操作中我们就能通过ssh连接树莓派。</p><h3 id="连接树莓派"><a href="#连接树莓派" class="headerlink" title="连接树莓派"></a>连接树莓派</h3><p>&emsp;&emsp;连接树莓派最简单的方法就是通过HDMI数据线连接显示屏，这样我们可以直接通过显示屏对树莓派进行操作。那如果我们没有显示屏，我们该如何连接树莓派呢？</p><h4 id="有路由器和网线的情况下"><a href="#有路由器和网线的情况下" class="headerlink" title="有路由器和网线的情况下"></a>有路由器和网线的情况下</h4><p>&emsp;&emsp;这种情况下连接树莓派也比较简单，我们只需要将网线的一端接入路由器的lan接口，一端接入树莓派的网络接口（树莓派会自动获取IP地址），同时我们的主机也连接在路由器所建立的局域网内，此时我们可以通过路由器查看树莓派的IP地址。获取树莓派IP地址之后，我们通过主机中的xshell或者putty等远程连接工具就可以连接到树莓派。</p><h4 id="有网线没有路由器的情况下"><a href="#有网线没有路由器的情况下" class="headerlink" title="有网线没有路由器的情况下"></a>有网线没有路由器的情况下</h4><p>&emsp;&emsp;没有了路由器，树莓派就不能获取到IP地址，这种情况稍微复杂一点。解决办法是：将网线的两端连接树莓派和主机，然后我们打开主机的网络和共享中心</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/raspberry/1.PNG" alt="avatar"></p><p>点击我们已经连接的网络，查看其属性</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/raspberry/2.PNG" alt="avatar"></p><p>点击共享按钮，勾选允许其他网络用户通过此计算机的Internet连接来连接（N）</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/raspberry/3.PNG" alt="avatar"></p><p>接下来我们回到网络和共享中心，点击未识别的网络那一栏对于的以太网选项，查看其详细信息，可以看到其IP地址，这里的IP为192.168.137.1</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/raspberry/4.PNG" alt="avatar"></p><p>然后我们拔掉网线，关掉树莓派，拔出内存卡，将其通过读卡器连接到主机上。我们进入内存卡的boot文件夹，修改comline.txt文件，将 ip = 192.168.137.100 这句话添加到开头。完成上述步骤之后，我们将内存卡插入树莓派，用网线重新连接树莓派和主机，启动树莓派电源。我们通过远程连接工具连接树莓派，此时树莓派的IP地址为刚才设置的192.168.137.100，不出意外的话，我们也能连接上树莓派。</p><h4 id="没有路由器没有网线的情况下"><a href="#没有路由器没有网线的情况下" class="headerlink" title="没有路由器没有网线的情况下"></a>没有路由器没有网线的情况下</h4><p>&emsp;&emsp;要使我们的主机能够远程连接到树莓派上，我们必须满足一个条件：主机和树莓派位于同一个局域网。没有路由器和网线的情况下，我们可以通过手机热点建立一个局域网环境，让树莓派和主机同时连接手机热点。现在需要解决的问题是如何才能让树莓派连接上手机的热点。开机状态下，树莓派的无线模块一直处于工作状态，我们需要将无线热点的相关配置文件写入系统。同样，我们通过读卡器读取内存卡boot文件夹，在文件夹下新建文件名为wpa_supplicant.conf的文件，在文件内写入手机热点的配置信息并保存。</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/raspberry/5.PNG" alt="avatar"></p><p>然后重新插入内存卡，开启树莓派，在手机上查看树莓派的IP地址，用远程连接工具进行连接。</p>]]></content:encoded>
      
      <comments>https://chaoge123456.github.io/%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5%E6%A0%91%E8%8E%93%E6%B4%BE.html/#disqus_thread</comments>
    </item>
    
    <item>
      <title>解释型语言python</title>
      <link>https://chaoge123456.github.io/%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80python.html/</link>
      <guid>https://chaoge123456.github.io/%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80python.html/</guid>
      <pubDate>Mon, 10 Sep 2018 15:14:35 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt; 计算机不能直接理解高级语言，只能直接理解机器语言，所以必须要把高级语言翻译成机器语言，计算机才能执行高级语言编写的程序。由于翻译方式的不同，习惯上我们大致把高级语言分为两类，即编译型语言和解释型语言。对于这两种类型的编程语言，很多人在
        
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>摘要</strong> 计算机不能直接理解高级语言，只能直接理解机器语言，所以必须要把高级语言翻译成机器语言，计算机才能执行高级语言编写的程序。由于翻译方式的不同，习惯上我们大致把高级语言分为两类，即编译型语言和解释型语言。对于这两种类型的编程语言，很多人在理解层面上存在盲点，本文将对这两种类型的编程语言进行探讨，帮助读者更好的理解这一问题。</p><h2 id="文章概览"><a href="#文章概览" class="headerlink" title="文章概览"></a>文章概览</h2><ul><li><p>编译型语言和解释型语言</p><ul><li>基本解释</li><li>优缺点</li></ul></li><li><p>python</p><ul><li>python解释器</li><li>python代码执行过程</li></ul></li></ul><h3 id="编译型语言和解释型语言"><a href="#编译型语言和解释型语言" class="headerlink" title="编译型语言和解释型语言"></a>编译型语言和解释型语言</h3><h4 id="基本解释"><a href="#基本解释" class="headerlink" title="基本解释"></a>基本解释</h4><p>&emsp;&emsp;对于编译型语言，我们以C语言为例，C语言在执行过程中，先要将源程序编译为目标文件（机器代码），该目标文件是与平台相关的，也就是说ARM生成的目标文件，不能被用于MIPS的CPU，也不能用于x86的CPU。目标文件经过连接操作就可以生成可执行文件，以后我们想再次运行这段代码时，不必进行编译操作，只需要直接执行生成的可执行文件即可。</p><p>&emsp;&emsp;对于解释型语言呢，我们不需要执行编译过程，程序在执行时直接由解释器逐句地对程序进行解释，转换为机器可以执行的代码。但是对于有些解释型语言来说，也需要进行编译操作，比如Java。Java程序在执行过程中先要将源代码编译成字节码文件，然后再由解释器对字节码文件逐句进行解释，所以说Java是一种先编译后解释的语言。（注：Java为了实现跨平台的特性，专门在从高级语言代码转换至机器码过程的中间加入了一层中间层JVM（java虚拟机），Java首先依赖编译器将代码（.java）编译成JVM能识别的字节码文件（.class），然后由JVM解释并执行该字节码，也可结合JIT（just-in-time compilation即时编译）技术，将解释生成的机器码转换为更高效的本地机器码，且该机器码可被缓存，来提高重复执行的效率。)</p><p>&emsp;&emsp;常见的编译型语言包括：C/C++、Pascal等，常见的编译型语言包括：Java、JavaScript、VBScript、Perl、Ruby、MATLAB 等。</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>编译型语言可以做到一次编译，多次运行，执行效率比较高；而解释型语言在每次执行时都需要解释器进行解释，执行效率较低（但是我们也不能一概而论，一些解释型语言也可以通过解释器的优化来在对程序做出翻译时对整个程序做出优化，从而在效率上超过编译型语言）。</li><li>编译型语言的执行依赖于平台，生成的可执行文件不能运行在其他平台，需重新编译，跨平台的性较差；而解释型语言的执行依赖于解释器，各个平台都有相应的解释器，解释器会将程序解释成基于当前机器指令集的机器码并执行，所以解释型语言可以很好的移植到其他平台，具有很好的跨平台性。</li><li>编译型语言，在编译阶段即可发现常见的语法或者链接等错误，此机制可在运行前帮助程序员排查出可能潜在的语法、语义和类型转换错误，编译型语言一般都有明确的变量类型检测，也被称作<strong>强类型语言</strong>，即编译型语言至少能确保所生成的可执行文件肯定是可运行的，至于执行的逻辑不对则属于程序员业务逻辑错误范畴了。而对于解释型语言，代码中的错误必须直到运行阶段方可发现，由此造成的困惑是：往往一段程序看不出问题但却在运行阶段错误连连且需要一个个排查：变量拼写错误、方法不存在等。但也正是基于解释是在运行期执行转化的特性，一般的解释型语言通常都有自己的shell，可以在不确定某些执行结果时立即“动手执行”试一下，这就比每次都需要编译后才能运行并看到结果省去不少时间。</li></ul><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><p>&emsp;&emsp;通过上面对编译型语言和解释型语言的分析，我们可以得出结论，python是属于解释型语言的一种。python类似于Java，为了效率上的考虑，也提供了编译方式，编译后生成的也是字节码的文件形式，并由Python的的VM（虚拟机）的去执行。不同点在于，Python的编译并非强制执行的操作，确切来说Python的编译是自动的，通常发生在对某个模块（module）的调用过程中，编译成字节码的可以节省加载模块的时间，以此达到提高效率的目的。可见，某些先进的高级语言在对编译和解释方面的拿捏舍去，都采取了一种：两手抓，两手都要硬的态度。</p><h4 id="python解释器"><a href="#python解释器" class="headerlink" title="python解释器"></a>python解释器</h4><p>&emsp;&emsp;由于整个Python语言从规范到解释器都是开源的，所以理论上，只要水平够高，任何人都可以编写Python解释器来执行Python代码（当然难度很大）。事实上，确实存在多种Python解释器</p><ul><li>CPython:  这个解释器是用C语言开发的，所以叫CPython。在命令行下运行python就是启动CPython解释器,它是使用最广的Python解释器.</li><li>IPython是基于CPython之上的一个交互式解释器，也就是说，IPython只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的。CPython用<code>&gt;&gt;&gt;</code>作为提示符，而IPython用<code>In [序号]:</code>作为提示符。</li><li>绝大部分Python代码都可以在PyPy下运行，但是PyPy和CPython有一些是不同的，这就导致相同的Python代码在两种解释器下执行可能会有不同的结果。PyPy是另一个Python解释器，它的目标是执行速度。PyPy采用<a href="http://en.wikipedia.org/wiki/Just-in-time_compilation" target="_blank" rel="noopener">JIT技术</a>，对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。</li><li>Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。</li></ul><h4 id="python代码执行过程"><a href="#python代码执行过程" class="headerlink" title="python代码执行过程"></a>python代码执行过程</h4><p>&emsp;&emsp;参考这篇<a href="https://blog.csdn.net/helloxiaozhe/article/details/78104975" target="_blank" rel="noopener">博客</a>和这篇<a href="https://www.cnblogs.com/kym/archive/2012/05/14/2498728.html" target="_blank" rel="noopener">博客</a></p>]]></content:encoded>
      
      <comments>https://chaoge123456.github.io/%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80python.html/#disqus_thread</comments>
    </item>
    
    <item>
      <title>决策树算法详解与python实现：ID3和CART</title>
      <link>https://chaoge123456.github.io/%E5%86%B3%E7%AD%96%E6%A0%91.html/</link>
      <guid>https://chaoge123456.github.io/%E5%86%B3%E7%AD%96%E6%A0%91.html/</guid>
      <pubDate>Sun, 09 Sep 2018 07:12:47 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt; 决策树是一种基本的分类与回归方法，本文主要讨论用于分类的决策树，决策树模型呈树形结构，在分类问题中，表示基于特征对实例进行分类的过程，它可以认为是if-then规则的集合，也可以认为是定义在特征空间与类空间上的条件概率分布，其主要优点
        
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>摘要</strong> 决策树是一种基本的分类与回归方法，本文主要讨论用于分类的决策树，决策树模型呈树形结构，在分类问题中，表示基于特征对实例进行分类的过程，它可以认为是if-then规则的集合，也可以认为是定义在特征空间与类空间上的条件概率分布，其主要优点是模型具有可读性，分类速度快。学习时，利用训练数据，根据损失函数最小化原则建立决策树模型。预测时，对新的数据，利用决策树模型进行分类。决策树学习通常包括三个步骤：特征选择、决策树的生成以及决策树的修剪。本文将主要讲解ID3和CART算法的原理和实现细节。  </p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/verify/tree.png" alt="avatar"></p><h2 id="文章概览"><a href="#文章概览" class="headerlink" title="文章概览"></a>文章概览</h2><ul><li>ID3算法<ul><li>特征选择</li><li>决策树的生成</li><li>ID3算法的缺陷</li><li>C4.5算法对ID3算法的改进</li></ul></li><li>CART算法<ul><li>特征选择</li><li>决策树生成</li><li>剪枝</li></ul></li></ul><h3 id="ID3算法"><a href="#ID3算法" class="headerlink" title="ID3算法"></a>ID3算法</h3><p>&emsp;&emsp;ID3算法是由澳大利亚计算机科学家Ross Quinlan提出的，它是构建决策树中一种非常重要的算法。在设计算法的过程中，它首次采用了信息增益准则来进行特征选择，这很大程度上推动了决策树算法的发展。</p><h4 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h4><p>&emsp;&emsp;我们可以将决策树看作是if- then规则的集合，使用决策树模型进行预测的过程就相当于对if - then规则进行判断，那我们可以想到如果if -then规则越多，也就是决策树越复杂，那么预测所需要的时间越长，所以为了不断优化决策树的决策过程，我们需要合理的构建决策树，那么如何来选择if - then的决策规则至关重要。</p><p>&emsp;&emsp;在ID3算法中，我们通过信息增益作为决策规则。信息增益 = 信息熵 - 条件熵，信息熵代表随机变量的不确定度，条件熵代表在一定条件下，随机变量的复杂度，所以信息增益表示在一定条件下信息复杂度减少的程度。信息增益越大说明该决策规则的区分度越高，在构建决策树时，我们选取信息增益最大的特征作为决策规则。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">emp_entropy</span><span class="params">(y_data)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    emp_entropy函数的主要功能是计算数据集的经验熵</span></span><br><span class="line"><span class="string">    :param y_data: 数据集的类别</span></span><br><span class="line"><span class="string">    :return: 返回数据集的经验熵</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    count = &#123;&#125;</span><br><span class="line">    emp = <span class="number">0.0</span></span><br><span class="line">    m = len(y_data)</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> y_data:</span><br><span class="line">        <span class="keyword">if</span> y <span class="keyword">in</span> count:</span><br><span class="line">            count[y] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            count[y] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> count.keys():</span><br><span class="line">        info = (<span class="number">1.0</span> * count[i] / m)</span><br><span class="line">        emp = emp + info * math.log(info,<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> emp</span><br></pre></td></tr></table></figure><p>emp_entropy函数的主要功能是计算数据集合的经验熵，经验熵的计算公式可以参考《统计学习方法》，同样，下面涉及到条件熵、信息增益的计算公式也可参考本书。代码中字典count的主要作用是统计数据集中不同类别出现的次数，emp即是信息增益。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">emp_cond_entropy</span><span class="params">(x_data,y_data,feature)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    emp_cond_entropy函数的主要作用是计算经验条件熵</span></span><br><span class="line"><span class="string">    :param x_data: 数据集</span></span><br><span class="line"><span class="string">    :param y_data: 数据集类别</span></span><br><span class="line"><span class="string">    :param feature: 数据集特征特征</span></span><br><span class="line"><span class="string">    :return: 数据集的经验条件熵</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    count_y = &#123;&#125;</span><br><span class="line">    emp_cond = <span class="number">0.0</span></span><br><span class="line">    m = len(y_data)</span><br><span class="line">    fea = x_data[:,feature]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(fea)):</span><br><span class="line">        <span class="keyword">if</span> fea[i] <span class="keyword">in</span> count_y:</span><br><span class="line">            count_y[fea[i]].append(y_data[i])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            count_y.setdefault(fea[i])</span><br><span class="line">            count_y[fea[i]] = []</span><br><span class="line">            count_y[fea[i]].append(y_data[i])</span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> count_y.keys():</span><br><span class="line">        l = len(count_y[e])</span><br><span class="line">        emp_cond = emp_cond + (<span class="number">1.0</span> * l / m) * emp_entropy(count_y[e])</span><br><span class="line">    <span class="keyword">return</span> emp_cond</span><br></pre></td></tr></table></figure><p>emp_cond_entropy函数的主要作用是计算经验条件熵，fenture表示数据的某一维特征，对于离散性特征（ID3算法不能处理连续型特征）来讲，特征的取值有多个，这里的count_y就是来统计该特征中不同取值的数据分布情况，列表fea表示的即是该数据集中该特征对应的值，emp_cond表示的是将该特征作为决策规则时的条件熵。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">choose_feature</span><span class="params">(x_data,y_data)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    choose_feature函数的主要作用是从数据集中选择信息增益最大的特征</span></span><br><span class="line"><span class="string">    :param x_data: 数据集</span></span><br><span class="line"><span class="string">    :param y_data: 数据集类别</span></span><br><span class="line"><span class="string">    :return: 信息增益最大的特征</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    n = np.size(x_data,<span class="number">1</span>)</span><br><span class="line">    count = []</span><br><span class="line">    emp = emp_entropy(y_data)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        emp_cond = emp_cond_entropy(x_data,y_data,i)</span><br><span class="line">        count.append(emp - emp_cond)</span><br><span class="line">    feature = count.index(min(count))</span><br><span class="line">    <span class="keyword">return</span> feature</span><br></pre></td></tr></table></figure><p>choose_feature函数的主要作用是从数据集中选择信息增益最大的特征，算法的思路就是对数据集进行遍历，计算每一个特征的信息增益，返回信息增益最大的特征。（由于在计算经验熵的过程中没有添加负号，所以我这里取的是负数的最小值，也就是正数的最大值）</p><h4 id="决策树的生成"><a href="#决策树的生成" class="headerlink" title="决策树的生成"></a>决策树的生成</h4><p>&emsp;&emsp;特征树的生成过程其实是一个递归过程，我们首先选择一个特征，作为根结点，根据根结点的不同取值，将数据集分为几个不同的部分，同时将该特征从数据集中删除。然后再对这几个不同的部分进行同样的操作，直到数据集类别相同或者没有特征为止。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_tree</span><span class="params">(x_data,y_data,feature_list_data)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    create_tree函数的主要作用是构建决策树</span></span><br><span class="line"><span class="string">    :param x_data:</span></span><br><span class="line"><span class="string">    :param y_data:</span></span><br><span class="line"><span class="string">    :param feature_list:</span></span><br><span class="line"><span class="string">    :return: 返回决策树</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    feature_list = feature_list_data[:]</span><br><span class="line">    <span class="keyword">if</span> is_all_same(y_data):</span><br><span class="line">        <span class="keyword">return</span> y_data[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> len(x_data) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> node_classfy(y_data)</span><br><span class="line">    feature = choose_feature(x_data,y_data)</span><br><span class="line">    node_name = feature_list[feature]</span><br><span class="line">    tree = &#123;node_name:&#123;&#125;&#125;</span><br><span class="line">    <span class="keyword">del</span> feature_list[feature]</span><br><span class="line">    count_x,count_y = feature_split(x_data,y_data,feature)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> count_x.keys():</span><br><span class="line">        fealist = feature_list[:]</span><br><span class="line">        count_x_del = del_feature(count_x[i],feature)</span><br><span class="line">        tree[node_name][i] = create_tree(count_x_del,count_y[i],fealist)</span><br><span class="line">    <span class="keyword">return</span> tree</span><br></pre></td></tr></table></figure><p>feature_list的作用是复制feature_list_data，因为后面要进行删除操作，我们要保证删除操作只能影响函数内部变量，不能对函数的实参造成影响。我们生成的决策树保存在tree字典中，每执行一次递归操作，相当于将当前特征作为一个字典的key，递归操作返回的即是一个子树（即字典）。</p><h4 id="ID3算法的缺陷"><a href="#ID3算法的缺陷" class="headerlink" title="ID3算法的缺陷"></a>ID3算法的缺陷</h4><p>&emsp;&emsp;通过对ID3算法进行分析，我们可以知道，ID3算法主要存在以下缺陷：</p><ul><li>ID3没有考虑连续型特征，数据集的特征必须是离散型特征</li><li>ID3算法采用信息增益大的特征优先建立决策树的结点，但是再计算信息增益的过程中我们发现，在相同条件下，取值比较多的特征比取值少的特征信息增益大</li><li>ID3没有对缺失值情况进行处理，现实任务中常会遇到不完整的样本，即样本的某些属性值缺失。</li><li>没有考虑过拟合问题</li></ul><h4 id="C4-5算法对ID3算法的改进"><a href="#C4-5算法对ID3算法的改进" class="headerlink" title="C4.5算法对ID3算法的改进"></a>C4.5算法对ID3算法的改进</h4><p>&emsp;&emsp;C4.5算法是对ID3算法存在的缺陷进行改进的一种算法，它通过将连续特征离散化来解决ID3算法不能处理离散型数据的问题（这个会在后面的CART算法中讲到）；通过引入信息增益比来解决信息增益的缺陷；通过增加剪枝操作来解决过拟合的问题。</p><h3 id="CART算法"><a href="#CART算法" class="headerlink" title="CART算法"></a>CART算法</h3><p>&emsp;&emsp;CART算法是一种应用广泛的决策树算法，它的基本流程与C4.5算法类似，它既可以应用于回归任务，也可以应用于分类任务（这里主要讲解分类树），需要注意的是CART算法生成的决策树是二叉树，而ID3和C4.5算法生成的决策树不一定是二叉树。</p><h4 id="特征选择-1"><a href="#特征选择-1" class="headerlink" title="特征选择"></a>特征选择</h4><p>&emsp;&emsp;CART算法的决策规则由基尼指数决定，选择基尼指数最小的特征及其切分点作为最优特征和最优切分点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Gini_index</span><span class="params">(y_data)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Gini_index函数的主要作用是计算数据集的基尼指数</span></span><br><span class="line"><span class="string">    :param y_data: 数据集类别</span></span><br><span class="line"><span class="string">    :return: 返回基尼指数</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    m = len(y_data)</span><br><span class="line">    count = &#123;&#125;</span><br><span class="line">    num = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> y_data:</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> count:</span><br><span class="line">            count[i] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            count[i] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> count.keys():</span><br><span class="line">        num = num + pow(<span class="number">1.0</span> * count[item] / m,<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span>-num)</span><br></pre></td></tr></table></figure><p>在前面提到过ID3算法只能处理离散型特征，而CART算法既能处理离散型特征，又能处理连续型特征。CART算法处理连续型特征的方法与C4.5算法类似，都是将连续特征离散化，即将连续特征的所有取值进行排序，然后计算相邻取值的平均值作为切分点，在以此计算基尼指数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">ef Gini_D_A(x_data,y_data,feature):</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Gini_D_A函数的主要作用是计算某一离散特征各个取值的基尼指数，选取最优切分点</span></span><br><span class="line"><span class="string">    :param x_data: 数据集合</span></span><br><span class="line"><span class="string">    :param y_data: 数据集类别</span></span><br><span class="line"><span class="string">    :param feature: 特征</span></span><br><span class="line"><span class="string">    :return: 该特征的最优切分点</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    Gini_data = list(x_data[:,feature])</span><br><span class="line">    y_data = list(y_data[:])</span><br><span class="line">    m = len(Gini_data)</span><br><span class="line">    Gini = &#123;&#125;</span><br><span class="line">    classfy_data = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> range(m):</span><br><span class="line">        <span class="keyword">if</span> Gini_data[e] <span class="keyword">not</span> <span class="keyword">in</span> classfy_data:</span><br><span class="line">            classfy_data[Gini_data[e]] = []</span><br><span class="line">        classfy_data[Gini_data[e]].append(y_data[e])</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> classfy_data.keys():</span><br><span class="line">        l1 = len(classfy_data[item])</span><br><span class="line">        r = y_data[:]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> classfy_data[item]:</span><br><span class="line">            r.remove(i)</span><br><span class="line">        l2 = len(r)</span><br><span class="line">        num = <span class="number">1.0</span> * l1 / m * Gini_index(classfy_data[item]) + <span class="number">1.0</span> * l2 / m * Gini_index(r)</span><br><span class="line">        Gini[item] = num</span><br><span class="line">    sor = sorted(Gini.items(), key=operator.itemgetter(<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> sor[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Gini_continuous</span><span class="params">(x_data,y_data,feature)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Gini_continous函数的主要作用是计算某一连续特征各个取值的基尼指数，选取最优切分点</span></span><br><span class="line"><span class="string">    :param x_data: 数据集合</span></span><br><span class="line"><span class="string">    :param y_data: 数据集类别</span></span><br><span class="line"><span class="string">    :param feature: 特征</span></span><br><span class="line"><span class="string">    :return: 该特征的最优切分点</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    Gini_data = list(x_data[:,feature])</span><br><span class="line">    m = len(Gini_data)</span><br><span class="line">    y_data = list(y_data[:])</span><br><span class="line">    sort_data = sorted(Gini_data)</span><br><span class="line">    Gini = &#123;&#125;</span><br><span class="line">    split_point = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m<span class="number">-1</span>):</span><br><span class="line">        num = (sort_data[i] + sort_data[i+<span class="number">1</span>]) / <span class="number">2.0</span></span><br><span class="line">        split_point.append(num)</span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> split_point:</span><br><span class="line">        count_y = &#123;<span class="number">0</span>:[],<span class="number">1</span>:[]&#125;</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">if</span> Gini_data[k] &lt;= e:</span><br><span class="line">                count_y[<span class="number">0</span>].append(y_data[k])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count_y[<span class="number">1</span>].append(y_data[k])</span><br><span class="line">        cal = <span class="number">1.0</span> * len(count_y[<span class="number">0</span>]) / m * Gini_index(count_y[<span class="number">0</span>]) + <span class="number">1.0</span> * len(count_y[<span class="number">1</span>]) / m * Gini_index(count_y[<span class="number">1</span>])</span><br><span class="line">        Gini[e] = cal</span><br><span class="line">    sor = sorted(Gini.items(), key=operator.itemgetter(<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> sor[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>当数据集中同时含有离散型变量和连续型变量时，进行特征选择就稍微有些复杂了，以下便是特征选择的代码,这里需要注意的是对不同类型特征的标识和对计算基尼指数时返回值的统一处理。dis_or_con是一个列表，用来标识特征是连续型还是离散型，0表示离散，1表示连续。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">choose_feature</span><span class="params">(x_data,y_data,dis_or_con)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    choose_feature函数的主要作用是从各个特征的各个切分点中选择基尼指数最小的切分点</span></span><br><span class="line"><span class="string">    :param x_data: 数据集合</span></span><br><span class="line"><span class="string">    :param y_data: 数据类别</span></span><br><span class="line"><span class="string">    :return: 切分点</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    w = np.size(x_data,axis=<span class="number">1</span>)</span><br><span class="line">    count = []</span><br><span class="line">    count_label = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(w):</span><br><span class="line">        <span class="keyword">if</span> dis_or_con[i] == <span class="number">0</span>:</span><br><span class="line">            a = Gini_D_A(x_data,y_data,i)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            a = Gini_continuous(x_data,y_data,i)</span><br><span class="line">        count.append(a[<span class="number">1</span>])</span><br><span class="line">        count_label[i] = a</span><br><span class="line">    id = count.index(min(count))</span><br><span class="line">    <span class="keyword">return</span> id,count_label[id][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h4 id="决策树的生成-1"><a href="#决策树的生成-1" class="headerlink" title="决策树的生成"></a>决策树的生成</h4><p>&emsp;&emsp;决策树的生成大致与ID3算法类似</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_tree</span><span class="params">(x_data,y_data,dis_or_con_data,feature_list_data)</span>:</span></span><br><span class="line"></span><br><span class="line">    feature_list = feature_list_data[:]</span><br><span class="line">    dis_or_con = dis_or_con_data[:]</span><br><span class="line">    <span class="keyword">if</span> dis_or_con == []:</span><br><span class="line">        <span class="keyword">return</span> most_y_data(y_data)</span><br><span class="line">    <span class="keyword">if</span> is_all_same(y_data):</span><br><span class="line">        <span class="keyword">return</span> y_data[<span class="number">0</span>]</span><br><span class="line">    w,f = choose_feature(x_data,y_data,dis_or_con)</span><br><span class="line">    count_x, count_y = feature_split(x_data,y_data,w,f,dis_or_con[w])</span><br><span class="line">    node_name = feature_list[w]</span><br><span class="line">    tree = &#123;(node_name,f):&#123;&#125;&#125;</span><br><span class="line">    <span class="keyword">del</span> feature_list[w]</span><br><span class="line">    <span class="keyword">del</span> dis_or_con[w]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> count_x.keys():</span><br><span class="line">        fealist = feature_list[:]</span><br><span class="line">        dis_con = dis_or_con[:]</span><br><span class="line">        count_x_del = del_feature(count_x[i], w)</span><br><span class="line">        tree[(node_name,f)][i] = create_tree(count_x_del, count_y[i], dis_con,fealist)</span><br><span class="line">    <span class="keyword">return</span> tree</span><br></pre></td></tr></table></figure><h4 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h4><p>&emsp;&emsp;本文暂未实现剪枝算法，有待后续补充</p>]]></content:encoded>
      
      <comments>https://chaoge123456.github.io/%E5%86%B3%E7%AD%96%E6%A0%91.html/#disqus_thread</comments>
    </item>
    
    <item>
      <title>验证码识别：找回四六级准考证号</title>
      <link>https://chaoge123456.github.io/verify-code.html/</link>
      <guid>https://chaoge123456.github.io/verify-code.html/</guid>
      <pubDate>Wed, 29 Aug 2018 12:27:33 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt; 一晃时间过的真快，距离上次更新博客已经将近10天了，这十天来也没闲着，回家终于把杀千刀的科目三过了，再也不用看到教练那张凶神恶煞的脸。前段时间四六级考试成绩公布了，小伙伴们是不是都第一时间忙着去查自己的成绩，相信有很多小伙伴跟我一样苦
        
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>摘要</strong> 一晃时间过的真快，距离上次更新博客已经将近10天了，这十天来也没闲着，回家终于把杀千刀的科目三过了，再也不用看到教练那张凶神恶煞的脸。前段时间四六级考试成绩公布了，小伙伴们是不是都第一时间忙着去查自己的成绩，相信有很多小伙伴跟我一样苦逼，幸幸苦苦复习了好长时间，查成绩的时候却忘了自己的准考证号（温馨提示：以后考试之前一定要记得把准考证拍一张存起来）。在网上试过无数种找回办法后，我彻底绝望了。既然别人不靠谱，咱就靠自己，经过两天的努力之后，终于成功的找回了准考证号。这篇博客主要来介绍解决这个问题的一些方法和思路。</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/verify/python.png" alt="avatar"></p><h1 id="文章概览"><a href="#文章概览" class="headerlink" title="文章概览"></a>文章概览</h1><ul><li><a href="#idea">基本思路</a>  </li><li><a href="#train">训练模型</a>  <ul><li>获取训练数据</li><li>处理数据</li><li>生成模型  </li></ul></li><li><a href="#select">查询操作</a>  <ul><li>发送请求</li><li>使用代理</li><li>多线程  </li></ul></li><li><a href="#instruction">使用教程</a></li></ul><p></p><h2 id="idea">基本思路</h2><br>&emsp;&emsp;对于查询四六级成绩来说，官方的查询入口有<a href="https://www.chsi.com.cn/cet/" target="_blank" rel="noopener">学信网</a>和<a href="http://cet.neea.edu.cn/cet/" target="_blank" rel="noopener">中国教育考试网</a>，查询成绩需要提交的数据包括准考证号、姓名和验证码。要想查询到成绩，最简单的办法就是手工枚举准考证号，一个一个的尝试。我们知道四六级准考证的组成如下所示（第10位表示类别，四级是1，六级是2）：<p></p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/verify/constitute.png" alt="avatar"></p><p>也就是说对于在同在一个考点的人来说前十位都是一致的（四级和六级不同），后面五位分别表示考场号和座位号（座位号从01到30），在我们忘记了考场号和座位号的情况下，我们至少要手工枚举几千次才有可能查询到成绩，这个工作难度可想而知。那如果我们不采用手工的方式进行枚举，而采用程序自动进行枚举呢？通过程序枚举准考证号不是什么问题，但是查询参数中包含验证码，现在需要解决地就是如何识别验证码。对于验证码地识别问题，我们可以利用机器学习的相关算法，建立识别模型，再利用识别模型来进行识别验证码。对于学信网和中国教育考试网两个网站，它们采用的验证码不同，学信网的验证码比较复杂，包含汉字等特殊字符，识别难度大，而中国教育考试网的验证码相对来说比较常规，识别难度相对小一点，本文的查询操作都是基于后者而言的。<br>&emsp;&emsp;那么我们解决问题地大致思路就是：首先我们要获取大量的验证码数据，然后选择算法训练识别验证码的模型，最后通过重复识别查询页面的验证码，提交查询数据，分析响应数据来获得最终的结果。  </p><p></p><h2 id="train">训练模型</h2><p></p><h3 id="获取训练数据"><a href="#获取训练数据" class="headerlink" title="获取训练数据"></a>获取训练数据</h3><p>&emsp;&emsp;通过抓取请求相应过程中的数据包，我们可以得到获取验证码的地址。</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/verify/imgurl.PNG" alt="avatar"></p><p>其中ik表示准考证号，我们可以随便填一个，t表示时间戳（这个可以不用管），我们可以不断地向这个地址发送请求，服务器的响应结果即为验证码的地址，我们再向获取到的验证码的地址发送请求，就可以得到验证码。</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/verify/imgresp.PNG" alt="avatar"></p><p>具体代码如下所示（该项目的所有代码都可以在<a href="https://github.com/chaoge123456/" target="_blank" rel="noopener">我的Github</a>中找到）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取验证码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_image_to_file</span><span class="params">()</span>:</span></span><br><span class="line">    myid = <span class="string">"123456789110211"</span></span><br><span class="line">    new_id = myid.format(id=myid)</span><br><span class="line">    img_api_url = image_api.format(id=new_id)</span><br><span class="line">    img_api_resp = requests.get(img_api_url, headers=img_api_headers,timeout=<span class="number">10</span>)</span><br><span class="line">    img_url, filename = get_image_url_and_filename(img_api_resp.text)</span><br><span class="line">    r = requests.get(img_url)</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"images/raw_picture/"</span> + filename, <span class="string">"wb+"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(r.content)</span><br></pre></td></tr></table></figure><h3 id="处理数据"><a href="#处理数据" class="headerlink" title="处理数据"></a>处理数据</h3><p>&emsp;&emsp;获取到一定数量的验证码图片后（大概需要100多张，收集的图片越多越好，之后我们会讲到一种快速收集和标注验证码的方法），接下来我们需要对获取到的验证码进行相应的处理。因为对于验证码的识别，我们一般采取监督学习的算法训练模型，所以首先要对获取到的验证码进行标注，即将验证码图片的文件名改为验证码对应的数字和字母组合，这一步必须要人工进行操作。然后，为了提高验证码识别的准确率，训练更好的识别模型，我们需要对验证码图片进行相应的处理，如灰度处理、二值化、降噪。经过这些手段处理后的验证码更能体现出图片本身的特征，同时也减小了训练模型时的计算量，具体代码如下所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 灰度处理，二值化（降噪部分的代码去掉了，效果不是太理想）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img_denoise</span><span class="params">(img, threshold)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init_table</span><span class="params">(threshold=threshold)</span>:</span></span><br><span class="line">        table = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">256</span>):</span><br><span class="line">            <span class="keyword">if</span> i &lt; threshold:</span><br><span class="line">                table.append(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                table.append(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> table</span><br><span class="line"></span><br><span class="line">    img = img.convert(<span class="string">"L"</span>).point(init_table(), <span class="string">'1'</span>)</span><br><span class="line">    <span class="keyword">return</span> img</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;下面我们要对验证码进行分割，因为在识别的时候，我们是识别单个的数字或字母，所以我们要将验证码进行切分，提取出每个字符对应的区域，切割后的每张图片大小一致。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 图片分割,参数img_split_start指定起始位置，参数img_split_width指定切割图片宽度</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img_split</span><span class="params">(img,img_split_start,img_split_width)</span>:</span></span><br><span class="line">    start = img_split_start</span><br><span class="line">    width = img_split_width</span><br><span class="line">    top = <span class="number">0</span></span><br><span class="line">    height = img.size[<span class="number">1</span>]</span><br><span class="line">    img_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        new_start = start + width * i</span><br><span class="line">        box = (new_start, top, new_start + width, height)</span><br><span class="line">        piece = img.crop(box)</span><br><span class="line">        <span class="comment">#piece.save("%s.jpg" % i)</span></span><br><span class="line">        img_list.append(piece)</span><br><span class="line">    <span class="keyword">return</span> img_list</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;图片切割完成后，数据处理的最后一步是将切割后的图片转化为numpy array的形式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将Image对象转换为array_list</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img_list_to_array_list</span><span class="params">(img_list)</span>:</span></span><br><span class="line">    array_list = []</span><br><span class="line">    <span class="keyword">for</span> img <span class="keyword">in</span> img_list:</span><br><span class="line">        array_list.append(array(img).flatten())</span><br><span class="line">    <span class="keyword">return</span> array_list</span><br></pre></td></tr></table></figure><p>以上这些操作大家可以在我的GitHub的项目文件中通过preprocessing()、make_train_data()和img_to_array()三个函数实现。</p><h3 id="生成模型"><a href="#生成模型" class="headerlink" title="生成模型"></a>生成模型</h3><p>&emsp;&emsp;生成模型主要用到的就是sklearn机器学习库中相关的算法，验证码识别属于分类任务，对于分类任务我们可以采用K近邻、支持向量机、决策树和神经网络等算法，这里我们采用的是支持向量机。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">svm_model</span><span class="params">(x_data,y_data)</span>:</span></span><br><span class="line">    SVM = svm.SVC()</span><br><span class="line">    x_train,x_test,y_train,y_test = train_test_split(x_data,y_data,random_state=<span class="number">14</span>)</span><br><span class="line">    SVM.fit(x_train,y_train)</span><br><span class="line">    y_predict = SVM.predict(x_test)</span><br><span class="line">    average_accuracy = np.mean(y_test==y_predict)*<span class="number">100</span></span><br><span class="line">    print(<span class="string">"准确率为：&#123;0:.1f&#125;%"</span>.format(average_accuracy))</span><br><span class="line">    pickle.dump(SVM, open(<span class="string">"model.pkl"</span>, <span class="string">"wb+"</span>))</span><br></pre></td></tr></table></figure><p>模型训练好之后，将模型对象存储在model.pkl文件中，需要识别验证码时，只需要读取model.pkl文件即可获得识别模型，不需要再次训练。</p><h2 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h2><h3 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h3><p>&emsp;&emsp;模型训练好之后，我们就可以进行查询操作了。这一阶段的大致思路是，先获取查询页面的验证码，通过识别模型进行识别，然后再向服务器提交请求参数，包括枚举的准考证号、姓名和验证码。如果服务器返回验证码错误，则重复以上操作。如果服务器返回查询结果为空则说明验证码正确，但是准考证号和姓名不一致，此时可以枚举下一个准考证号，重复操作一直到获得正确结果为止。</p><p>&emsp;&emsp;由于一开始我们训练模型时使用的训练数据量很小，所以该识别模型识别的准确率比较低，那么如何提高模型识别的准确率呢。最好的办法就是增大训练数据的数量，训练新的模型。这里提供一个更快更方便获取训练数据的方法，在发送请求的代码中，我们加入两行代码（倒数第三行和倒数第二行），该代码的作用时将识别正确的验证码加入到训练数据的文件夹中，并且会自动进行标注，可以通过该方式一边查询，一边收集大量的训练数据。我的项目中，一开始手工标注的验证码有200张，训练模型后采用这种方式自动收集了1600多张验证码，然后利用所有的训练数据重新建立模型，识别的准确率提高了30%。（但是这样的做法存在一个过拟合的问腿，训练模型对于类似于一开始200张验证码的图片的识别准确率比较高，而对于其他类型的图片识别的准确率比较低。不过这个问题对于我们找回准考证号影响不大，提高准确率最好的就是一开始手工标注更多的验证码）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发送请求</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_query_until_true</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="comment"># 生成准考证号</span></span><br><span class="line">    <span class="keyword">global</span> proxy</span><br><span class="line">    new_id = myid.format(id=num)</span><br><span class="line">    <span class="comment"># 获取验证码图片地址</span></span><br><span class="line">    img_api_url = image_api.format(id=new_id)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            img_api_resp = requests.get(img_api_url,        headers=img_api_headers,timeout=<span class="number">10</span>,proxies=proxy)</span><br><span class="line">            img_url, filename = get_image_url_and_filename(img_api_resp.text)</span><br><span class="line">            <span class="comment"># 获取验证码图片并猜测</span></span><br><span class="line">            img_resp = requests.get(img_url, timeout=<span class="number">10</span>, proxies=proxy)</span><br><span class="line">            <span class="keyword">if</span> img_resp.status_code == <span class="number">200</span>:</span><br><span class="line">                images = Image.open(BytesIO(img_resp.content))</span><br><span class="line">                code = img_verify_code(images)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                code = <span class="string">"xxxx"</span></span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            print(<span class="string">"重新获取代理"</span>)</span><br><span class="line">            p = str(get_proxy())</span><br><span class="line">            proxy = &#123;<span class="string">'http'</span>: <span class="string">'http://'</span> + p, <span class="string">'https'</span>: <span class="string">'http://'</span> + p&#125;</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># CET4成绩查询选项</span></span><br><span class="line">    <span class="comment"># data = &#123;"data": "CET4_181_DANGCI,&#123;id&#125;,&#123;name&#125;".format(id=new_id, name=name),"v": code&#125;</span></span><br><span class="line">    <span class="comment"># CET6成绩查询选项</span></span><br><span class="line">    data = &#123;<span class="string">"data"</span>: <span class="string">"CET6_181_DANGCI,&#123;id&#125;,&#123;name&#125;"</span>.format(id=new_id, name=name),<span class="string">"v"</span>: code&#125;</span><br><span class="line">    query_resp = requests.post(query_api, data=data, headers=query_api_headers)</span><br><span class="line">    query_text = query_resp.text</span><br><span class="line">    log_info(query_text.split(<span class="string">"'"</span>)[<span class="number">3</span>],new_id)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">"验证码错误"</span> <span class="keyword">in</span> query_text:</span><br><span class="line">        query_text = send_query_until_true(num)</span><br><span class="line">    <span class="comment"># elif "您查询的结果为空" in query_text:</span></span><br><span class="line">    <span class="comment">#     images.save("images/save_picture/" + code + ".png")</span></span><br><span class="line">    <span class="keyword">return</span> query_text</span><br></pre></td></tr></table></figure><h3 id="使用代理"><a href="#使用代理" class="headerlink" title="使用代理"></a>使用代理</h3><p>&emsp;&emsp;在上面那段代码中，我们在请求过程中使用了代理，是为了防止频繁请求导致ip被封，代理功能可以自动切换代理，保证程序的正常运行。在测试过程中我们发现，该网站不会对ip进行封锁，所以代理可有可无。这里大致说一下代理功能是如何实现的。</p><p>&emsp;&emsp;代理功能使用的代理池是Github上的开源项目，它通过从代理平台抓取可用的代理ip存储到本地Redis中，需要使用代理时，即从本地Redis中取出。使用代理功能需要进行相应的配置。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">安装并开启<span class="selector-tag">Redis</span>服务器</span><br><span class="line">安装依赖 <span class="selector-tag">pip3</span> <span class="selector-tag">install</span> <span class="selector-tag">-r</span> <span class="selector-tag">requirements</span><span class="selector-class">.txt</span></span><br><span class="line">开启代理服务 <span class="selector-tag">python</span> <span class="selector-tag">run</span><span class="selector-class">.py</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述代码中，我们使用了捕捉异常的语句，因为在使用代理的过程中我们发现代理ip可能存在网络不稳定，传输有延时等问题。总的来说，使用代理的查询速度很慢，不想使用代理的话直接将proxy配置成本地的ip和端口即可。</p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>&emsp;&emsp;在开发过程中，想过用多线程，但是效果不太理想（对并行编程不熟悉），后来想想对于查找准考证号这种问题可以根据实际情况灵活，可能有些人会大致记得自己的考场位于哪个区间之内，所以在项目中，提供了输入查询区间的接口。如果想提高查询速度，可以开启多个终端，每个终端输入不同的查询区间，这样就类似于开启了多进程（一般查询的时候开启10个终端，每个终端的考场区间为10，10分钟内可以查询到结果）。</p><h2 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h2><p>&emsp;&emsp;简单介绍一下该项目的文件结构，如图所示。</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/verify/content.PNG" alt="avatar"></p><ul><li>images：主要用来存放验证码图片，images中包含多个目录，row_picture存放原始验证码，change_picture存        * 放灰度化、二值化处理后的验证码，train_data存放分割后的验证码</li><li>proxypool：实现代理功能的相关代码</li><li>acquire_picture.py：包含验证码获取、处理相关操作的代码</li><li>model.pkl：存放识别模型</li><li>recongnition_code.py：项目的执行入口，包含向服务器发送请求、代理等相关代码</li><li>setting.py：项目相关的配置文件</li><li>train_data_preprocessing.py：整合验证码获取和处理相关操作</li><li>train_model.py：训练模型</li></ul><p>&emsp;&emsp;该项目使用的大致流程如下（要求python版本不低于3.5，该项目在win10环境测试运行无误）。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">安装相关依赖PIL、requests、numpyy、sklearn等</span><br><span class="line">修改recongnition_code.<span class="keyword">py</span>文件中的myid（准考证号前<span class="number">10</span>位）、name（自己的名字）</span><br><span class="line">修改recongnition_code.<span class="keyword">py</span>文件中成绩查询选项</span><br><span class="line">如果需要使用代理，需要配置代理相关环境</span><br><span class="line">在项目文件夹中打开终端输入：<span class="keyword">python</span> recongnition_code.<span class="keyword">py</span> 开始区间 结束区间</span><br><span class="line">可同时开启多个终端，每个设置不同的区间，加快查找速度</span><br></pre></td></tr></table></figure><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/verify/start.PNG" alt="avatar"></p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/verify/end.PNG" alt="avatar"></p>]]></content:encoded>
      
      <comments>https://chaoge123456.github.io/verify-code.html/#disqus_thread</comments>
    </item>
    
    <item>
      <title>2018年下半年学习计划</title>
      <link>https://chaoge123456.github.io/plan.html/</link>
      <guid>https://chaoge123456.github.io/plan.html/</guid>
      <pubDate>Wed, 15 Aug 2018 02:25:02 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;摘要:&lt;/strong&gt; 即将开始研究生阶段的学习生活了，我希望这对于我来说是一个全新的开始。所有伟大的梦想都源于一个切实可行的计划，为了迎接即将开始的旅程，我也需要这样一个计划，希望在它的鞭策和激励下让我不断成长，奋力前行！&lt;br&gt;&lt;img src=&quot;ht
        
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>摘要:</strong> 即将开始研究生阶段的学习生活了，我希望这对于我来说是一个全新的开始。所有伟大的梦想都源于一个切实可行的计划，为了迎接即将开始的旅程，我也需要这样一个计划，希望在它的鞭策和激励下让我不断成长，奋力前行！<br><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/KNN/plan.jpg" alt="avatar"></p><h1 id="计划大纲"><a href="#计划大纲" class="headerlink" title="计划大纲"></a>计划大纲</h1><ul><li><a href="#August">2018.8.16-2018.9.1</a>  <ul><li>机器学习算法实现系列博客（贝叶斯分类器和决策树）</li><li>学习python数据结构和算法  </li></ul></li><li><a href="#September">2018.9.2-2018.9.30</a>  <ul><li>阅读高质量论文两篇 </li><li>完成机器学习算法实现系列博客（大概5篇）</li><li>开始阅读《凸优化理论》 </li></ul></li><li><a href="#October">2018.10.1-2018.10.31</a>  <ul><li>阅读高质量论文三篇</li><li>完成《凸优化理论》的学习</li><li>开始阅读流畅的python  </li><li>博客写作三篇  </li></ul></li><li><a href="#November">2018.11.1-2018.11.30</a>  <ul><li>阅读高质量论文三篇</li><li>完成流畅的python</li><li>学习javascript  </li><li>博客写作三篇</li></ul></li><li><a href="#December">2018.12.1-2018.12.31</a>  <ul><li>阅读高质量论文三篇</li><li>学习node.js</li><li>阅读HTTP协议详解  </li><li>博客写作三篇</li></ul></li><li><a href="#January">2018.1.1-2018.1.31</a><ul><li>阅读高质量论文三篇</li><li>搭建node.js网站</li><li>学习docker  </li><li>博客写作三篇</li></ul></li></ul><h2 id="August">八月学习计划完成情况</h2>]]></content:encoded>
      
      <comments>https://chaoge123456.github.io/plan.html/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
