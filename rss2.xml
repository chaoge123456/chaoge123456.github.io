<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>小生很忙</title>
    <link>https://chaoge123456.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>网络安全和机器学习相关技术分享</description>
    <pubDate>Thu, 22 Aug 2019 07:44:26 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>对抗样本生成系列：FGSM和DeepFool</title>
      <link>https://chaoge123456.github.io/%E5%AF%B9%E6%8A%97%E6%A0%B7%E6%9C%AC%E7%94%9F%E6%88%90%E7%B3%BB%E5%88%97%EF%BC%9AFGSM%E5%92%8CDeepfool.html/</link>
      <guid>https://chaoge123456.github.io/%E5%AF%B9%E6%8A%97%E6%A0%B7%E6%9C%AC%E7%94%9F%E6%88%90%E7%B3%BB%E5%88%97%EF%BC%9AFGSM%E5%92%8CDeepfool.html/</guid>
      <pubDate>Tue, 20 Aug 2019 06:11:01 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;近些年来，深度学习技术在海量数据以及强大计算能力的驱动下取得了长足的发展，特别是在语音识别、计算机视觉、自然语言处理等领域，深度学习以其强大的网络表达能力刷新了一项又一项记录，各种各样基于深度学习的产品和服务也逐渐在产业界落地应用。正
        
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>摘要：</strong>近些年来，深度学习技术在海量数据以及强大计算能力的驱动下取得了长足的发展，特别是在语音识别、计算机视觉、自然语言处理等领域，深度学习以其强大的网络表达能力刷新了一项又一项记录，各种各样基于深度学习的产品和服务也逐渐在产业界落地应用。正因为深度学习技术蕴含着巨大的商业价值，其背后潜在的安全问题更值得我们去深究。最近的研究表明，深度学习面临安全和隐私等多方面的威胁。该系列主要讨论深度学习领域最为热门的安全问题–对抗样本。本文讨论的FGSM和DeepFool是较为的早期对抗样本的生成算法，除此之外还会对DeepFool衍生出的Universal Perturbation进行解读。</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/adversarial/panda.jpg" alt="avatar"></p><h2 id="文章概览"><a href="#文章概览" class="headerlink" title="文章概览"></a>文章概览</h2><ul><li>FGSM<ul><li>算法概述</li><li>代码实现</li></ul></li><li>DeepFool<ul><li>算法概述</li><li>代码实现</li></ul></li><li>Universal Perturbation </li></ul><h3 id="FGSM"><a href="#FGSM" class="headerlink" title="FGSM"></a>FGSM</h3><h4 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h4><p>&emsp;&emsp;在机器学习领域，对抗样本的问题始终存在。特别是在入侵检测、垃圾邮件识别等传统的安全应用场景，对抗样本的生成和识别一直是攻击者和防御者博弈的战场。2013年，Szegedy等人首次提出针对深度学习场景下的对抗样本生成算法–<a href="https://arxiv.org/abs/1312.6199" target="_blank" rel="noopener">BFGS</a>，作者认为，深度神经网络所具有的强大的非线性表达能力和模型的过拟合是可能产生对抗性样本原因之一。2014年，Goodfellow等人（包括Szegedy）对该问题进行了更深层次的研究，它们认为高维空间下深度神经网络的线性线性行为是导致该问题的根本原因。并根据该解释，设计出一种快速有效的生成对抗性样例的算法–<a href="https://arxiv.org/abs/1412.6572" target="_blank" rel="noopener">FGSM</a>。以下是对论文的解读。</p><p>&emsp;&emsp;对于线性模型$f(x)=w^Tx+b$来说，如果我们对输入$ x $添加一些扰动，使得$ \tilde{x}=x+\eta $。为了确保添加的扰动是极小的或者说是无法感知的，我们要求$ \left|\eta\right|_\infty&lt;\epsilon $。所以我们可以得到加噪后的模型输出为<br>$$<br>f(\tilde{x})=w^Tx+w^T\eta+b<br>$$<br>为了尽可能增大添加的噪声对输出结果的影响，令$\eta=\epsilon sign(w)​$（<a href="https://baike.baidu.com/item/sign%E5%87%BD%E6%95%B0/1343199" target="_blank" rel="noopener">sign()函数的定义</a>)。如果$w​$是一个$n​$维的向量，每一维的均值为$m​$，则$w^T\eta=\epsilon nm​$。虽然$\epsilon​$的值很小，但是当$w​$的维度$n​$很大时，$\epsilon nm​$将是一个很大的值，这将会给模型的预测带来很大的影响。因此，高维特征和线性行为可以成为对抗性样本存在的一种解释。</p><p>&emsp;&emsp;上面的解释是基于线性模型而言的，而深度神经网络作为一种高度非线性模型，为什么会存在对抗性样例呢？深度神经网络的非线性单元赋予了其强大的表达能力，但是非线性单元的存在会降低学习的效率。为了提高学习效率，需要对非线性单元进行改进，通常的做法是通过降低其非线性来实现。从早期的sigmoid到tanh再到ReLU，我们会发现这些非线性单元的线性行为在不断增强，这也导致了深度神经网络中的线性能力的增强，这在一定程度上解释了深度神经网络中对抗性样例存在的原因。</p><p>&emsp;&emsp;根据这种解释，作者提出了生成对抗性样例的算法FGSM。我们将深度神经网络模型看作是一个线性模型，即类似于$f(x)=w^Tx+b$。在线性模型中，$w$为$f(x)$关于$x$的导数，而在深度神经网络模型中我们可以将$w$视为代价函数关于输入$x​$的导数，即<br>$$<br>w=\nabla_{x}J(\theta,x,y)<br>$$</p><p>$$<br>\eta=\epsilon sign(\nabla_{x}J(\theta,x,y))<br>$$</p><p>&emsp;&emsp;在文章的后半部分主要介绍了针对对抗性样本的防御机制，即通过对抗性训练来提高模型的鲁棒性，这些内容会在之后的工作中讨论。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>&emsp;&emsp;为了更好的理解算法的实现过程，以下给出本文相关的代码段。这些代码段给出的定义，对于后面的DeepFool和Universal Perturbation算法的解读依赖有效。所有的代码基于python实现，使用的深度学习框架为pytorch，更加完整的算法实现，参加<a href="https://github.com/chaoge123456/MLsecurity/tree/master/blog/FGSM%20and%20DeepFool" target="_blank" rel="noopener">我的github</a>.</p><ul><li><p>网络模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Net, self).__init__()</span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">28</span>*<span class="number">28</span>, <span class="number">300</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">300</span>, <span class="number">100</span>)</span><br><span class="line">        self.fc3 = nn.Linear(<span class="number">100</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x = F.relu(self.fc1(x))</span><br><span class="line">        x = F.relu(self.fc2(x))</span><br><span class="line">        x = self.fc3(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure></li><li><p>数据集（这里只给出测试集的数据定义）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义数据转换格式</span></span><br><span class="line">mnist_transform = transforms.Compose([transforms.ToTensor(), transforms.Lambda(<span class="keyword">lambda</span> x : x.resize_(<span class="number">28</span>*<span class="number">28</span>))])</span><br><span class="line"><span class="comment"># 导入数据，定义数据接口</span></span><br><span class="line">testdata  = torchvision.datasets.MNIST(root=<span class="string">"./mnist"</span>, train=<span class="keyword">False</span>, download=<span class="keyword">True</span>, transform=mnist_transform)</span><br><span class="line">testloader = torch.utils.data.DataLoader(testdata, batch_size=<span class="number">256</span>, shuffle=<span class="keyword">True</span>, num_workers=<span class="number">0</span>)</span><br></pre></td></tr></table></figure></li><li><p>代价函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loss_function = nn.CrossEntropyLoss()</span><br></pre></td></tr></table></figure></li></ul><p>&emsp;&emsp;FGSM算法的实现较为简单，其核心在于利用代价函数求解已知样本的梯度值。我们假设模型已经训练完成，首先我们加载已训练完成的深度网络模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net = torch.load(<span class="string">'mnist_net_all.pkl'</span>) <span class="comment"># 加载模型</span></span><br></pre></td></tr></table></figure><p>然后我们选择一个测试样本，针对该测试样本生成其对应的对抗性样例。其原始图片格式如图所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">index = <span class="number">100</span> <span class="comment"># 选择测试样本</span></span><br><span class="line">image = Variable(testdata[index][<span class="number">0</span>].resize_(<span class="number">1</span>,<span class="number">784</span>), requires_grad=<span class="keyword">True</span>) <span class="comment"># requires_grad存储梯度值</span></span><br><span class="line">label = torch.tensor([testdata[index][<span class="number">1</span>]])</span><br></pre></td></tr></table></figure><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/adversarial/origin.PNG" alt="avatar"></p><p>接着将测试样本作为网络模型的输入，通过前向传播的过程计算其损失，然后利用其损失进行反向传播（即求导）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">outputs = net(image) <span class="comment"># 前向传播</span></span><br><span class="line">loss = loss_function(outputs, label) <span class="comment"># 计算损失</span></span><br><span class="line">loss.backward() <span class="comment"># 反向传播</span></span><br></pre></td></tr></table></figure><p>在深度学习框架中，反向传播的过程对用户来说是透明的。计算结束后，其梯度值存储在image.data.grad中，添加扰动的过程如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># FGSM添加扰动</span></span><br><span class="line">epsilon = <span class="number">0.1</span> <span class="comment"># 扰动程度</span></span><br><span class="line">x_grad = torch.sign(image.grad.data)</span><br><span class="line">x_adversarial = torch.clamp(image.data + epsilon * x_grad, <span class="number">0</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>添加扰动后，得到对抗性样本如下所示</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/adversarial/adversary_1.PNG" alt="avatar"></p><p>实验过程中我们发现，深度网络模型对于原始的图片能够正确的分类，而对于扰动之后的的样本不能正确分类（分类结果为2）。</p><h3 id="DeepFool"><a href="#DeepFool" class="headerlink" title="DeepFool"></a>DeepFool</h3><h4 id="算法概述-1"><a href="#算法概述-1" class="headerlink" title="算法概述"></a>算法概述</h4><p>&emsp;&emsp;FGSM算法能够快速简单的生成对抗性样例，但是它没有对原始样本扰动的范围进行界定（扰动程度$\epsilon$是人为指定的），我们希望通过最小程度的扰动来获得良好性能的对抗性样例。2016年，Seyed等人提出的<a href="https://www.cv-foundation.org/openaccess/content_cvpr_2016/html/Moosavi-Dezfooli_DeepFool_A_Simple_CVPR_2016_paper.html" target="_blank" rel="noopener">DeepFool</a>算法很好的解决了这一问题。文章的核心思想是希望找到一种对抗性扰动的方法来作为对不同分类器对对抗性扰动鲁棒性评估的标准。简单来说就是，现在我需要两个相同任务的分类器A、B针对同一个样本生成各自的对抗性样例。对于分类器A而言，其生成对抗性样例所需要添加的最小扰动为$a$；对于分类器B而言，其生成对抗性样例所需要添加的最小扰动为$b$；通过对$a$、$b$的大小进行比较，我们就可以对这两个分类器对对抗性样例的鲁棒性进行评估。由于FGSM产生扰动是人为界定的，所以它不能作为评估的依据。DeepFool可以生成十分接近最小扰动的对抗性样例，因此它可以作为衡量分类器鲁棒性的标准。</p><p>&emsp;&emsp;DeepFool源于对分类问题的思考。对于如图所示的线性二分类问题，令$f(x)=w^Tx+b$，其中$\mathscr{F}={x : f(x)=0}$。此时$x_0$位于直线的下方，即$f(x_0)&gt;0$。现在我们希望对$x_0$添加扰动$r$，使得分类器$f(x_0+r)&lt;0$。那么如何添加扰动才能使得扰动的程度最小呢？这个问题可以转化为求点到直线之间的距离，我们通过$x_0$做直线$\mathscr{F}$的垂线，与$\mathscr{F}$相交于$p$（投影点），则$p$与$x_0$之间的距离即为$x_0$到分类边界$\mathscr{F}$的最短距离。所以当我们沿着分类边界法线方向对$x_0​$进行扰动，可以保证扰动的程度最小<br>$$<br>r(x_0):={\arg\min_k}{|{r}|_{2}}=-{\frac{f(x_0)}{|{w}|_{2}^{2}}{w}}<br>$$<br>添加扰动之后将$x_0$映射到分类边界的投影点$p$，即$p=x_0+r(x_0)​$。</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/adversarial/linear.PNG" alt="avatar"></p><p>&emsp;&emsp;同样，对于非线性的二分类问题（分类边界为曲线或者曲面），我们也需要计算从目标样本点到分类边界的最短距离。这个计算过程较为复杂，一般采用垂直逼近法来逐步的逼近$x_0​$在分类边界上的投影点，所以在论文中算法1会有一个迭代过程。值得注意的是，我们得到最终的$\sum_i{r_i}​$表示的是从$x_0​$到分类边界投影点的距离向量，满足$f(x_0+\sum_i{r_i})=0​$。如果要使分类结果改变，需要再添加一些极小的扰动，如$f(x_0+(1+\eta)\sum_i{r_i})&lt;0​$（文中$\eta​$取0.02）。</p><p>&emsp;&emsp;对于多分类任务，思路也大致相同。在线性多分类任务中，需要注意的大致有两点：首先，对于多分类任务的分类边界要重新进行定义。我们令$f(x)​$为分类器，$\hat{k}(x)=\mathop{\arg\max}_{k}{f_k(x)}​$表示其对应的分类结果（一共有$k​$个类别）。分类边界定义为<br>$$<br>\mathscr{F}_k={x : f_k(x)-f_{\hat{k}(x_0)}(x)=0}<br>$$<br>其次，由于分类边界有多个，我们需要以此求出$x_0​$到每个分类边界的距离（类似于进行多次二分类的计算过程），然后进行比较，选择其中最短距离向量作为最终的扰动。<br>$$<br>\hat{l}(x_0)=\mathop{\arg\min_{k \neq \hat{k}_{x_0} }}{\frac{|f_k(x_0)-f_{\hat{k}(x_0)}(x_0)|}{|{w_k -w_{\hat{k}_{x_0}}}|_2}}<br>$$<br>之后通过计算$\boldsymbol{r}(x_0)​$得到$x_0​$在分类边界上的投影。</p><p>&emsp;&emsp;在非线性多分类任务中，与线性多分类的区别在于其分类边界是不确定的，所以我们需要采用类似于非线性二分类任务中的方法来逼近分类边界。获得分类边界之后的计算与线性多分类的过程类似。此后，重复该过程多次，即可获得最终$x_0​$在分类边界的投影。</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><p>&emsp;&emsp;以下讨论多分类情况下DeepFool算法的代码实现，模型结构以及数据集等与上述一致，不再重复。首先，我们选择一个测试样本，生成该样本的对抗性样例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">net = torch.load(<span class="string">'mnist_net_all.pkl'</span>) <span class="comment"># 加载模型</span></span><br><span class="line">index = <span class="number">100</span> <span class="comment"># 选择测试样本</span></span><br><span class="line">image = Variable(testdata[index][<span class="number">0</span>].resize_(<span class="number">1</span>,<span class="number">784</span>), requires_grad=<span class="keyword">True</span>)</span><br><span class="line">label = torch.tensor([testdata[index][<span class="number">1</span>]])</span><br></pre></td></tr></table></figure><p>接下来，通过前向传播的过程，我们获得该样本对每一类别可能的取值情况，并将其从大到小排列起来，列表$I$对应其索引值，$label$即$\hat{k}_{x_0}$。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">f_image = net.forward(image).data.numpy().flatten() </span><br><span class="line"><span class="comment"># f_image: [-1.1256416 , -1.0344085 ,  2.0596995 , -2.0181773 , -0.24274658, -0.53373957,  6.6361637 , -2.250309  ,  0.06580263, -3.0854702 ]</span></span><br><span class="line"></span><br><span class="line">I = (np.array(f_image)).flatten().argsort()[::<span class="number">-1</span>]</span><br><span class="line"><span class="comment"># I: [6, 2, 8, 4, 5, 1, 0, 3, 7, 9]</span></span><br><span class="line"></span><br><span class="line">label = I[<span class="number">0</span>] <span class="comment"># 该样本的标签为6</span></span><br></pre></td></tr></table></figure><p>然后，我们定义一些需要用到的变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">input_shape = image.data.numpy().shape <span class="comment"># 获取原始样本的维度</span></span><br><span class="line">pert_image = copy.deepcopy(image) <span class="comment"># 深度复制原始样本</span></span><br><span class="line">w = np.zeros(input_shape) </span><br><span class="line">r_tot = np.zeros(input_shape)</span><br><span class="line"></span><br><span class="line">loop_i = <span class="number">0</span> </span><br><span class="line">max_iter = <span class="number">50</span> <span class="comment"># 最多迭代次数</span></span><br><span class="line">overshoot = <span class="number">0.02</span>  </span><br><span class="line">x = Variable(pert_image, requires_grad=<span class="keyword">True</span>)</span><br><span class="line">fs = net.forward(x)</span><br><span class="line">fs_list = [fs[<span class="number">0</span>][I[k]] <span class="keyword">for</span> k <span class="keyword">in</span> range(len(I))] <span class="comment"># 每个类别的取值情况，及其对应的梯度值</span></span><br><span class="line">k_i = label</span><br></pre></td></tr></table></figure><p>下面是算法实现的核心部分，参考论文中的伪代码，其中orig_grad表示$\nabla f_{\hat{k}_{x_0}}(x_i)$，cur_grad表示$\nabla f_k(x_i)$，fs[0][I[k]]表示$f_k(x_i)$，fs[0][I[0]]表示$f_{\hat{k}_{x_0}}(x_i)$。通过内部的for循环可以获得x到各分类边界的距离；在外部的while循环中，我们利用内部循环获得的所有边界距离中的最小值对x进行更新。重复这一过程，直到$x​$的分类标签发生变化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> k_i == label <span class="keyword">and</span> loop_i &lt; max_iter:</span><br><span class="line">    pert = np.inf</span><br><span class="line">    fs[<span class="number">0</span>][I[<span class="number">0</span>]].backward(retain_graph=<span class="keyword">True</span>)</span><br><span class="line">    orig_grad = x.grad.data.numpy().copy() </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(len(I)):</span><br><span class="line">        zero_gradients(x)</span><br><span class="line">        fs[<span class="number">0</span>][I[k]].backward(retain_graph=<span class="keyword">True</span>)</span><br><span class="line">        cur_grad = x.grad.data.numpy().copy()</span><br><span class="line">        </span><br><span class="line">        w_k = cur_grad - orig_grad</span><br><span class="line">        f_k = (fs[<span class="number">0</span>][I[k]] - fs[<span class="number">0</span>][I[<span class="number">0</span>]]).data.numpy()</span><br><span class="line">        </span><br><span class="line">        pert_k = abs(f_k) / np.linalg.norm(w_k.flatten())</span><br><span class="line">        <span class="keyword">if</span> pert_k &lt; pert: <span class="comment"># 获得最小的分类边界距离向量</span></span><br><span class="line">            pert = pert_k</span><br><span class="line">            w = w_k</span><br><span class="line">    r_i = (pert + <span class="number">1e-4</span>) * w / np.linalg.norm(w) </span><br><span class="line">    r_tot = np.float32(r_tot + r_i) <span class="comment"># 累积扰动</span></span><br><span class="line">    </span><br><span class="line">    pert_image = image + (<span class="number">1</span>+overshoot)*torch.from_numpy(r_tot) <span class="comment"># 添加扰动</span></span><br><span class="line">    x = Variable(pert_image, requires_grad=<span class="keyword">True</span>)</span><br><span class="line">    fs = net.forward(x)</span><br><span class="line">    k_i = np.argmax(fs.data.numpy().flatten()) <span class="comment"># 扰动后的分类标签</span></span><br><span class="line">    loop_i += <span class="number">1</span></span><br><span class="line">r_tot = (<span class="number">1</span>+overshoot)*r_tot <span class="comment"># 最终累积的扰动</span></span><br></pre></td></tr></table></figure><p>对原始图片，添加扰动获得如下图片（分类器将其错误分类为2，有些奇怪的地方在于其扰动的程度要大FGSM，算法应该没有问题，一直没找到原因）。</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/adversarial/deepfool.PNG" alt="avatar"></p><h3 id="Universal-Perturbation"><a href="#Universal-Perturbation" class="headerlink" title="Universal Perturbation"></a>Universal Perturbation</h3><p>&emsp;&emsp;前面介绍的FGSM和DeepFool算法，它们都是针对单个样本生成其对抗性样例，也就是说每个对抗性样例的扰动程度都不同。那么是否能找到一种通用性的扰动边界，能够为不同的样本生成对抗性样例。在DeepFool工作的基础上，Seyed 等人提出了Universal Perturbation，该算法为寻找通用性扰动边界提供了可能。以下简单介绍一下论文的核心思想：</p><ul><li>从数据集中随机选取部分测试样本作为生成通用性扰动边界的范例，通过这些测试样本生成的通用性扰动适用于整个数据集。</li><li>算法的计算过程：输入第一个样本后，通过DeepFool算法找到该样本的最小扰动距离向量，将其累积到通用扰动向量$v$中（对$v$的扰动程度会有限制和调整，${|v|_p&lt;\xi}$）；当输入第二个样本之后，对其添加$v$的扰动之后，然后再通过DeepFool计算扰动后的样本的最小扰动距离向量，将其累积到通用扰动向量$v$中（对$v$的扰动程度会有限制和调整,${|v|_p&lt;\xi}$）。重复这一过程，直到最后一个测试样本。然后，我们使用通用扰动向量$v$，对原始的测试样本进行扰动，测试其生成对抗性样例的成功率。如果小于预先设置的阈值$1-\delta$，则跳出循环返回结果。否则，重复上述过程。</li><li>通用性扰动对不同的网络模型依然有效。也就是说，利用网络模型A生成的通用性扰动，同样适用于生成网络模型B的对抗性样例（A、B是不同类型的网络架构）。</li></ul>]]></content:encoded>
      
      <comments>https://chaoge123456.github.io/%E5%AF%B9%E6%8A%97%E6%A0%B7%E6%9C%AC%E7%94%9F%E6%88%90%E7%B3%BB%E5%88%97%EF%BC%9AFGSM%E5%92%8CDeepfool.html/#disqus_thread</comments>
    </item>
    
    <item>
      <title>校园网环境下服务器双网卡配置</title>
      <link>https://chaoge123456.github.io/%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%8C%E7%BD%91%E5%8D%A1%E9%85%8D%E7%BD%AE.html/</link>
      <guid>https://chaoge123456.github.io/%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%8C%E7%BD%91%E5%8D%A1%E9%85%8D%E7%BD%AE.html/</guid>
      <pubDate>Sun, 21 Apr 2019 06:02:31 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;最近一段时间在忙着写论文、看论文，博客一直没有更新了。这几天实验室添了两台交换机和五台服务器，这对于我这个爱折腾的人来说，确实是个大喜事，老师也把实验室设备的管理工作全权交予我来负责。忙活了几天时间，装好了系统，建立了一个小
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><p><strong>摘要：</strong>最近一段时间在忙着写论文、看论文，博客一直没有更新了。这几天实验室添了两台交换机和五台服务器，这对于我这个爱折腾的人来说，确实是个大喜事，老师也把实验室设备的管理工作全权交予我来负责。忙活了几天时间，装好了系统，建立了一个小型的Hadoop集群和私有云。这其中我觉得最有意思的是关于实验室网络环境的配置，所以在这里做一些分享。</p><hr><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/network/tcp.jpg" alt="avatar"></p><h2 id="文章概览"><a href="#文章概览" class="headerlink" title="文章概览"></a>文章概览</h2><ul><li><p>网络环境简介</p></li><li><p>双网卡配置</p></li><li>Linux密码</li></ul><h3 id="网络环境简介"><a href="#网络环境简介" class="headerlink" title="网络环境简介"></a>网络环境简介</h3><p>&emsp;&emsp;一开始，实验室的服务器都没有分配校园网固定IP，为了对服务器进行安装配置，我用了一台闲置的交换机和一个二手路由器组建了一个简单的网络环境（服务器—&gt;交换机—&gt;路由器）。但是存在的问题是，服务器只能在实验室的网络环境才能访问，无法通过校园网访问。一些内网映射的工具又不太稳定，使用起来很不方便，最关键的是路由器成为了整个网络的瓶颈（几十块钱的路由器）。后来通过学校网络中心分配了几个固定的校园网IP，但是校园网IP不能直接连接外网，需要拨号才能联网。五台服务器也就意味着需要五个账号才能使所有的服务器同时连接外网，我也没有这么多账号。仔细考虑了一下我们当前的需求和配置：</p><ul><li>所有的服务器能通过校园网直接访问</li><li>所有的服务器能同时连接外网</li><li>宽带账号只有一个，路由器一个，交换机一个</li></ul><p>综合这些因素，配置服务器双网卡可能是一个好的选择。每台服务器都有多个网口，将每台服务器同时连接在校园网和路由器两个网络中就能满足这些需求。通过给连接在校园网的网口配置校园网固定IP，可以保证校园网对服务器的访问；通过路由器拨号上网，将服务器的另一个网口连接到路由器上，即可保证服务器对外网的访问。</p><h3 id="双网卡配置"><a href="#双网卡配置" class="headerlink" title="双网卡配置"></a>双网卡配置</h3><h3 id="Linux密码"><a href="#Linux密码" class="headerlink" title="Linux密码"></a>Linux密码</h3><p>&emsp;&emsp;之前一个同学在实验室主机上装过centos，可能太长时间没用，所以root密码忘了。找回LInux密码的过程挺有意思，一般情况下，通过单用户模式可以对root密码进行修改，但是系统设置了grub密码（防止修改用户密码）。至于grub密码就更不记得了，于是我们又想通过救援模式去修改grub密码，然后再修改root密码。参考了很多教程，我们发现修改不了grub密码。就在准备放弃的时候，我发现救援模式下可以直接访问/etc/shadow文件，我试着将文件中root用户记录删除，竟然修改成功了。重新开机之后，奇迹发生了，可以使用root用户直接登录了。这里给出<a href="https://www.tecmint.com/recover-or-rescue-corrupted-grub-boot-loader-in-centos-7/" target="_blank" rel="noopener">参考的博客链接</a>，希望对大家有所帮助。</p>]]></content:encoded>
      
      <comments>https://chaoge123456.github.io/%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%8C%E7%BD%91%E5%8D%A1%E9%85%8D%E7%BD%AE.html/#disqus_thread</comments>
    </item>
    
    <item>
      <title>tor匿名网络</title>
      <link>https://chaoge123456.github.io/Tor%E5%8C%BF%E5%90%8D%E7%BD%91%E7%BB%9C.html/</link>
      <guid>https://chaoge123456.github.io/Tor%E5%8C%BF%E5%90%8D%E7%BD%91%E7%BB%9C.html/</guid>
      <pubDate>Wed, 28 Nov 2018 19:14:32 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt; 前段时间看到一篇报道，暗网最大的托管商遭到黑客攻击，6500+网站被删。根据知道创宇平台的暗网雷达显示，一夜之间活跃在暗网中的网站从12000+下降到5000+，几乎遭到团灭，这一事件让暗网再次进入人们的视野。一直以来，暗网被赋予了
        
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>摘要：</strong> 前段时间看到一篇报道，暗网最大的托管商遭到黑客攻击，6500+网站被删。根据知道创宇平台的暗网雷达显示，一夜之间活跃在暗网中的网站从12000+下降到5000+，几乎遭到团灭，这一事件让暗网再次进入人们的视野。一直以来，暗网被赋予了很多传奇的色彩，本文将带你一步步揭开暗网的神秘面纱。</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/tor/tor.jpg" alt="avatar"></p><hr><h2 id="文章概览"><a href="#文章概览" class="headerlink" title="文章概览"></a>文章概览</h2><ul><li>基本概念<ul><li>深网</li><li>暗网</li><li>黑暗网络</li></ul></li><li>tor匿名网络 <ul><li>tor基本概述</li><li>tor网络结构</li><li>tor路由技术</li><li>tor匿名服务</li></ul></li><li>tor客户端代理</li></ul><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>&emsp;&emsp;在介绍暗网之前，我们先来了解一下经常会混淆的三个概念“深网”(Deep web)、“暗网”(Dark web) 和“黑暗网络”(Darknet) 。</p><h4 id="深网"><a href="#深网" class="headerlink" title="深网"></a>深网</h4><p>&emsp;&emsp;深网是指服务器上可通过标准的网络浏览器和连接方法访问的页面和服务，但主流搜索引擎不会收录这些页面和服务。搜索引擎之所以不会收录深网，通常是因为网站或服务的配置错误、拒绝爬虫爬取信息、需要付费查看、需要注册查看或其他内容访问限制。据不完全统计，互联网世界中只有4％是对公众开放，剩下的96％的网站和数据则隐藏在深网中。</p><h4 id="暗网"><a href="#暗网" class="headerlink" title="暗网"></a>暗网</h4><p>&emsp;&emsp;暗网是深网中相对较小的一部分，与被故意隐藏的 Web 服务和页面有关。仅使用标准浏览器无法直接访问这些服务和页面，必须依靠使用覆盖网络 (Overlay Network)；而这种网络需要特定访问权限、代理配置、专用软件或特殊网络协议。</p><h4 id="黑暗网络"><a href="#黑暗网络" class="headerlink" title="黑暗网络"></a>黑暗网络</h4><p>&emsp;&emsp;黑暗网络是在网络层访问受限的框架，例如 tor 或 I2P，私有 VPN 也属于这个类别。通过这些框架的网络流量会被屏蔽。当进行数据传输时，系统只会显示您连接的黑暗网络以及您传输了多少数据，而不一定会显示您访问的网站或所涉及数据的内容。与之相反的是，直接与明网（Clean Net）或与未加密的表网服务和深网服务交互。在这种情况下，您与所请求资源之间的互联网服务提供商和网络运营商可以看到您传输的流量内容。</p><h3 id="tor匿名网络"><a href="#tor匿名网络" class="headerlink" title="tor匿名网络"></a>tor匿名网络</h3><h4 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h4><p>&emsp;&emsp;经过上面的描述，我们对暗网整体的框架有个大致的了解。暗网不同于普通的互联网络，它拥有特殊的运作方式和网络协议，tor 是目前世界范围内是最大的暗网。tor又名洋葱网络，最初是由美国军方的情报机构开发并且提供财务支持的。洋葱网络使用特殊的路由转发技术，即洋葱路由技术。洋葱路由技术利用 P2P 网络,把网络流量随机地通过 P2P 的节点进行转发，这样可以掩盖源地址与目标地址的路径，使得在 Internet 上难以确定使用者的身份和地址。这就类似于你给某人送一封匿名信，你不是自己去送或者通过邮局的邮差去送，而是在大街上随便找几个不认识的人让他帮你送，这样收信人就很难往回追踪找到你。</p><p>&emsp;&emsp;洋葱路由项目最初进展缓慢,废弃了其中的几个版本。直到 2002 年才由麻省理工的两位毕业生 Roger Dingledine 和 Nick Mathewson 以及原项目组成员 PaulSyverson 一起开发出一个新版的洋葱路由，也就是Tor。“洋葱路由”的最初目的并不是保护大众的隐私，它的目的是帮助政府情报人员隐藏身份，网上活动不被敌对国家监控。后来为了混淆系统的流量，而不是让系统仅仅拥有来自美国安全部门网络的流量，他们又让系统中加入来自其它网络的流量。于是，tor 的普通版本被推广给了普通大众，让普通大众也能使用 tor 来保护自己的隐私。这样就可以把政府情报人员的流量与社会上各行各业用户的复杂流量混在一起，能让流量分析更加困难，提供更强地隐私保护。</p><p>&emsp;&emsp;目前全球范围内，tor网络由超过一万七千个中继节点组成，每个中继节点都是由全球志愿者免费提供，这些中继节点大部分分布在欧洲和北美。暗网除了能给我们提供匿名的网络服务之外，在按暗网中也存在各种类型的网站，这些网站只有通过暗网才能够访问。暗网中的网站大部分都是提供一些“特殊的服务”，包括枪支、毒品、网络攻击等等。</p><h4 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h4><p>Tor 匿名网络结构主要由目录服务器、洋葱代理、洋葱路由器这三部分组成。</p><ul><li><strong>目录服务器：</strong>它负责收集和更新网络中所有可运行的中继节点信息，为客户端提供节点公钥等建立链路所需的必要信息。目前，绝大多数的目录服务器在欧美地区,只有极少数分布在亚洲。</li><li><strong>洋葱代理：</strong>它是 tor 用户的客户端代理程序，负责下载目录服务器中的路由信息，选择节点和建立路径，并对通信信息进行加解密。</li><li><strong>洋葱路由器（又称中继节点）：</strong>它是构建匿名通信链路的基础，负责转发 tor 客户端和网络服务器的通信信息，是实现匿名通信的关键。目前整个 tor 网络中有几千个路由节点分布在世界各地，这些中继节点又分为三种类型:<ul><li>Entry/Guard 中继节点──这是 tor 网络的入口节点。这些中继节点运行一段时间后，如果被证明是稳定的，并具有高带宽，就会被选来作为 Guard 中继节点。</li><li>Middle 中继节点──Middle 中继节点是位于中间节点位置上的洋葱路由器，充当流量从 Guard 中继节点传输到 Exit 中继节点的桥梁，这可以避免 Guard 中继节点和 Exit 中继节点探查到彼此的位置。</li><li>Exit 中继节点──位于出口节点位置上的洋葱路由器，负责将 Tor 网络内的流量转发到网络外部的互联网中去。每个出口节点都有一个相关的出口政策，该政策规定该节点能通过哪个端口转发何种协议的流量来防止滥用 tor 网络。</li></ul></li></ul><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/tor/tor_structure.jpeg" alt="avatar"></p><p>&emsp;&emsp;tor 网络主要依赖于这些中继节点转发用户流量，tor 通过随机选取遍布于全球由志愿者运行的三个中继节点，然后分别与选择的入口节点、中间节点、出口节点协商会话密钥。用这些协商的密钥将通信数据先进行多层加密，然后再将加密的数据在三个洋葱路由器组成的通信链路上传送。数据每经过一个洋葱路由器就像是剥去一层洋葱皮一样解密去掉一个加密层，以此得到下一跳路由信息，然后将数据继续发往下一个洋葱路由器，不断重复此过程,直到数据送达目的地。这种转发方式能防止那些知道数据发送端以及接收端的中间人窃听数据内容。</p><h4 id="tor路由技术"><a href="#tor路由技术" class="headerlink" title="tor路由技术"></a>tor路由技术</h4><p>以下步骤讲述了Alice在使用tor与Bob的服务器进行通讯时，tor是如何工作的。</p><ul><li>Alice开启tor客户端代理，获取来自tor 目录服务器（Dave）中的tor节点（或中继的列表）以及它们的公钥。</li></ul><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/tor/tor_work1.png" alt="avatar"></p><ul><li>Alice 选择三个节点建立通信链路。Alice 得到入口中继节点的 IP 地址和身份摘要，和入口节点协商一个只用于两者之间通信的短暂会话密钥。成功建立一跳的链路以后，Alice 使用同样地方法要求入口节点拓展链路到中间节点，得到了 Alice与中间节点的短暂会话密钥。Alice 重复此过程直至建立一条含有三跳的通信链路并且获得三个她与三个节点独一无二的短暂会话密钥。整个链路建立过程中的所有连接都是加密的。然后Alice 向 Bob 发送服务请求，并且将请求内容使用三个会话密钥按由远到近的顺序依次加密。入口节点接收到解密消息后会使用会话密钥将其解密一层，并将仍然加密的信息转发给中间节点。直至到达出口节点后，才将信息解密为明文。图中的虚线表示出口节点与 Bob 之间的连接是未加密的，出口节点将原始数据发送给 Bob。Bob 回复请求内容，并且每个节点会以相反的加密顺序加密一层,最终送还给 Alice。</li></ul><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/tor/tor_work2.png" alt="avatar"></p><ul><li>如果 Alice 与 Bob 通信时间较长，Alice 每隔几分钟会重新选择三个节点建立新的通信链路以防攻击者窃听。如果 Alice 想要访问另一服务器 Jane，她也会重新选择中继节点建立新的通信链路。</li></ul><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/tor/tor_work3.png" alt="avatar"></p><h4 id="tor匿名服务"><a href="#tor匿名服务" class="headerlink" title="tor匿名服务"></a>tor匿名服务</h4><p>&emsp;&emsp;之前提到暗网中也存在很多网站，这些网站在提供相应的服务时（暗网中大部分网络服务都是违法的）也希望是匿名的，即用户无法追踪到关于该网站的相关信息。下面主要讲解用户Alice和匿名服务器Bob交互的具体过程。</p><ul><li>服务器Bob与tor网络中的一些中继节点连接，请求这些中继节点作为匿名服务的接入点，并将Bob的公钥发送给这些中继节点。注意Bob和中继节点之间的连接也是匿名的，这些中继节点无法获取关于Bob的相关位置信息。</li></ul><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/tor/THS-1.png" alt="avatar"></p><ul><li>Bob将之前建立的接入点的相关信息和自己的公钥组装成描述符，并用自己的私钥该描述符进行签名，然后将其发送到目录服务器。通过Bob的公钥可以生成一个16位的字符串，记为XYZ。当客户端请求XYZ.onion时就可以找到对应Bob的描述符。</li></ul><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/tor/THS-2.png" alt="avatar"></p><ul><li>Alice通过某些渠道获得了tor域名XYZ.onion，Alice想要访问该服务器。她通过tor客户端访问XYZ.onion，此时可以从目录服务器中获取对应服务器的描述符，通过描述符可以知道Bob服务器的接入点和公钥。与此同时，Alice会提前建立另外一条私密临时会话点，用于下一步与Bob交互。</li></ul><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/tor/THS-3.png" alt="avatar"></p><ul><li>当确认描述符存在且临时通道准备好之后，Alice用描述符中的公钥加密一条信息，包括临时会话点和会话秘钥，将加密后的信息发送给描述符中的接入点，之后接入点会将加密信息发送到对应的服务器（即Bob的服务器）。</li></ul><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/tor/THS-4.png" alt="avatar"></p><ul><li>Bob收到加密信息后将其解密，获取临时会话点和会话秘钥。然后和临时会话点建立匿名连接，连接成功后，临时会话点会通知Alice。之后Alice和Bob可以通过临时会话点进行通信，注意通信过程中建立的连接都是匿名的。</li></ul><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/tor/THS-5.png" alt="avatar"></p><h3 id="tor客户端代理"><a href="#tor客户端代理" class="headerlink" title="tor客户端代理"></a>tor客户端代理</h3><p>&emsp;&emsp;如果只是希望匿名浏览web网页，我们可以通过<a href="https://www.torproject.org/projects/torbrowser.html.en" target="_blank" rel="noopener">tor浏览器</a>来实现。tor浏览器是基于火狐浏览器改造而来，可以方便的帮助我们连接到tor，实现网络匿名。如果想要在更多应用中实现网络匿名，我们可以安装tor客户端代理。以下配置过程基于ubuntu，且默认已安装shadowsocks。</p><h4 id="安装polipo"><a href="#安装polipo" class="headerlink" title="安装polipo"></a>安装polipo</h4><p>&emsp;&emsp;polipo是轻量级的跨平台代理服务器，可以实现http和socks代理，polipo本地服务端口为8123。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install polipo</span><br></pre></td></tr></table></figure><p>安装完成后，修改配置文件/etc/polipo/config</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">socksParentProcy = "localhost:9050" #tor服务本地端口为9050</span><br><span class="line">socksProxyType = socks5</span><br></pre></td></tr></table></figure><h4 id="安装tor"><a href="#安装tor" class="headerlink" title="安装tor"></a>安装tor</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install tor</span><br></pre></td></tr></table></figure><p>安装完成后，修改配置文件/etc/tor/torrc，添加以下内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SOCKS5Proxy 127.0.0.1:1080 #shadowsocks本地服务端口为1080</span><br></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>&emsp;&emsp;完成上述操作后，开启polipo、tor和shadowsocks。如果我们希望在chrome浏览器中实现网络匿名，可以通过添加tor代理来实现。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代理协议：socks5    代理服务器：127.0.0.1    代理端口：9050</span><br></pre></td></tr></table></figure><p>如果我们希望在命令行中实现网络匿名，可以通过polipo代理来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_proxy=http://localhost:8123 "需要执行的操作“</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://chaoge123456.github.io/Tor%E5%8C%BF%E5%90%8D%E7%BD%91%E7%BB%9C.html/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Hadoop分布式集群搭建</title>
      <link>https://chaoge123456.github.io/Hadoop%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA.html/</link>
      <guid>https://chaoge123456.github.io/Hadoop%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA.html/</guid>
      <pubDate>Thu, 22 Nov 2018 01:29:17 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;：Hadoop，是一个分布式系统基础架构，由Apache基金会开发。用户可以在不了解分布式底层细节的情况下，开发分布式程序。充分利用集群的威力高速运算和存储。简单地说来，Hadoop是一个可以更容易开发和运行处理大规模数据的软件平台。该
        
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>摘要</strong>：Hadoop，是一个分布式系统基础架构，由Apache基金会开发。用户可以在不了解分布式底层细节的情况下，开发分布式程序。充分利用集群的威力高速运算和存储。简单地说来，Hadoop是一个可以更容易开发和运行处理大规模数据的软件平台。该平台使用的是面向对象编程语言Java实现的，具有良好的可移植性。本文将介绍Hadoop相关的技术框架以及搭建Hadoop平台的详细过程。</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/hadoop/hadoop1.png" alt="avatar"></p><h2 id="文章概览"><a href="#文章概览" class="headerlink" title="文章概览"></a>文章概览</h2><ul><li>Hadoop简介<ul><li>Hadoop体系结构</li><li>HDFS分布式文件系统</li><li>MapReduce编程模型</li></ul></li><li>Hadoop平台搭建</li></ul><h3 id="Hadoop简介"><a href="#Hadoop简介" class="headerlink" title="Hadoop简介"></a>Hadoop简介</h3><h4 id="Hadoop体系结构"><a href="#Hadoop体系结构" class="headerlink" title="Hadoop体系结构"></a>Hadoop体系结构</h4><p><img src="https://i.ytimg.com/vi/f6UmOlD7NkA/maxresdefault.jpg" alt="avatar"></p><h4 id="HDFS分布式文件系统"><a href="#HDFS分布式文件系统" class="headerlink" title="HDFS分布式文件系统"></a>HDFS分布式文件系统</h4><p>&emsp;&emsp;在正式讨论HDFS分布式文件系统之前，我们首先了解一下什么是文件系统。文件系统实际上可以看作是一个用户与底层数据交互的一个接口，对于底层数据而言它定义了数据的存储和组织方式，同时也提供了存储空间的管理功能；而对于用户而言它使用文件和树形目录的抽象逻辑概念代替了存储设备中块的概念，用户使用文件系统来操作数据不必关心数据实际保存在硬盘（或者光盘）的地址为多少的数据块上，只需要记住这个文件的所属目录和文件名（关于文件系统更详细的介绍参见<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">维基百科</a>和<a href="https://linux.cn/article-8887-1.html" target="_blank" rel="noopener">这篇博客</a>)。传统文件系统适用于存储容量小等一些没有特殊要求的应用场景。</p><p>&emsp;&emsp;但是随着信息技术的不断发展，人们可以获取的数据成指数倍的增长，单纯通过增加硬盘个数来扩展计算机文件系统的存储容量的方式，在容量大小、容量增长速度、数据备份、数据安全等方面的表现都差强人意。为了满足这些特殊应用场景的需求，分布式文件系统应运而生。分布式文件系统可以有效解决数据的存储和管理难题：将固定于某个地点的某个文件系统，扩展到任意多个地点/多个文件系统，众多的节点组成一个文件系统网络。每个节点可以分布在不同的地点，通过网络进行节点间的通信和数据传输。人们在使用分布式文件系统时，无需关心数据是存储在哪个节点上、或者是从哪个节点从获取的，只需要像使用本地文件系统一样管理和存储文件系统中的数据（我们需要知道的是在分布式文件系统的每个数据结点上，数据的存储方式是建立在传统文件系统的基础上的，所谓分布式文件系统它提供的是数据宏观上的存储和管理方式）。</p><p>&emsp;&emsp;HDFS是分布式文件系统的一种，它采用master/slave架构，一个HDFS集群是由一个Namenode和一定数目的Datanodes组成。它可以处理超大规模的数据，并且提供了良好的容错机制，下图是HDFS的基本结构。</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/hadoop/HDFS.png" alt="avatar"></p><ul><li><strong>NameNode:</strong> 可以看作是分布式文件系统中的管理者，主要负责管理文件系统的命名空间、集群配置信息和存储块的复制等，NameNode会将文件系统的Meta-data存储到内存中，这些信息主要包括了文件信息、每一个文件对应的文件块的信息和每一个文件块在DataNode的信息等。</li><li><strong>Datanode:</strong> DataNode是文件存储的基本单元，他将Block存储在本地文件系统中，保存了Block的meta-data，同时周期性的将所有存在的Block信息发送给NameNode。slave存储实际的数据块，执行数据块的读写。</li><li><strong>Client:</strong> 文件切分与NameNode的交互，获取文件位置信息；与DataNode交互，读取或者写入数据；管理HDFS；访问HDFS。</li></ul><h5 id="HDFS读取数据流程"><a href="#HDFS读取数据流程" class="headerlink" title="HDFS读取数据流程"></a>HDFS读取数据流程</h5><p>客户端将要读取的文件路径发送给Namenode，Namenode获取文件的元信息（主要是block的存放位置信息）返回给客户端，客户端根据返回的信息找到相应Datanode逐个获取文件的block并在客户端本地进行数据追加合并从而获得整个文件</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/hadoop/HDFS_Read.png" alt="avatar"></p><h5 id="HDFS写数据流程"><a href="#HDFS写数据流程" class="headerlink" title="HDFS写数据流程"></a>HDFS写数据流程</h5><p>客户端要向HDFS写数据，首先要跟Namenode通信以确认可以写文件并获得接收文件block的Datanode，然后，客户端按顺序将文件逐个block传递给相应Datanode，并由接收到block的Datanode负责向其他Datanode复制block的副本。</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/hadoop/HDFS_Write.png" alt="avatar"></p><h4 id="MapReduce编程模型"><a href="#MapReduce编程模型" class="headerlink" title="MapReduce编程模型"></a>MapReduce编程模型</h4><p>&emsp;&emsp;MapReduce的诞生也是由于对大规模数据处理的需求。在大型的互联网公司，比如说Google、亚马逊等，在他们的平台上每天都会产生大量的数据，单个的处理器不可能在有限的时间内完成计算。根据多线程和并行计算的启发，我们可以将这些计算分布在成百上千的的机器上，这些机器集群就可以看作硬件资源池，将并行的任务拆分，然后交由每一个空闲机器资源去处理，能够极大地提高计算效率。但是由此而来引发的问题是在这个分布式计算系统中应该如何合理的处理并行计算？如何分发数据？如何处理错误？为了避免对这些问题的考虑，我们希望获得这样一个抽象模型，在这个模型中我们只需要关注我们希望执行的任务，而不必关心并行计算、容错、数据分布、负载均衡等复杂的细节，MapReduce就是这样一个抽象模型。</p><p>&emsp;&emsp;MapReduce 是一个编程模型，也是一个处理和生成超大数据集的算法模型的相关实现。用户首先创建一 个 Map 函数处理一个基于 key/value pair 的数据集合， 输出中间的基于 key/value pair 的数据集合； 然后再创建 一个 Reduce 函数用来合并所有的具有相同中间 key 值的中间 value 值。MapReduce 架构的程序能够在大量的普通配置的计算机上实现并行化处理。这个系统在运行时只关心： 如何分割输入数据，在大量计算机组成的集群上的调度，集群中计算机的错误处理，管理集群中计算机之间 必要的通信。采用 MapReduce 架构可以使那些没有并行计算和分布式处理系统开发经验的程序员有效利用分布式系统的丰富资源。</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/hadoop/MapReduce.jpg" alt="avatar"></p><h5 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h5><ul><li>用户程序首先调用的 MapReduce 库将输入文件分成 M 个数据片度，每个数据片段的大小一般从 16MB 到 64MB(可以通过可选的参数来控制每个数据片段的大小)。然后用户程序在机群中创建大量 的程序副本。</li><li>这些程序副本中的有一个特殊的程序–master。副本中其它的程序都是 worker 程序，由 master 分配 任务。有 M 个 Map 任务和 R 个 Reduce 任务将被分配，master 将一个 Map 任务或 Reduce 任务分配 给一个空闲的 worker。 </li><li>被分配了 map 任务的 worker 程序读取相关的输入数据片段，从输入的数据片段中解析出 key/value pair，然后把 key/value pair 传递给用户自定义的 Map 函数，由 Map 函数生成并输出的中间 key/value pair，并缓存在内存中。</li><li>缓存中的 key/value  pair 通过分区函数分成 R 个区域，之后周期性的写入到本地磁盘上。缓存的 key/value  pair 在本地磁盘上的存储位置将被回传给 master，由 master 负责把这些存储位置再传送给 Reduce worker</li><li>当 Reduce worker 程序接收到 master 程序发来的数据存储位置信息后， 使用 RPC 从 Map worker 所在的磁盘上读取这些缓存数据。当 Reduce worker 读取了所有的中间数据后，通过对 key 进行排序 后使得具有相同 key 值的数据聚合在一起。由于许多不同的 key 值会映射到相同的 Reduce 任务上， 因此必须进行排序。如果中间数据太大无法在内存中完成排序，那么就要在外部进行排序。</li><li>Reduce worker 程序遍历排序后的中间数据， 对于每一个唯一的中间 key 值， Reduce worker 程序将这 个 key 值和它相关的中间 value 值的集合传递给用户自定义的 Reduce 函数。Reduce 函数的输出被追加到所属分区的输出文件。</li><li>当所有的 Map 和 Reduce 任务都完成之后，master 唤醒用户程序。在这个时候，在用户程序里对 MapReduce 调用才返回。</li></ul><h3 id="Hadoop平台搭建"><a href="#Hadoop平台搭建" class="headerlink" title="Hadoop平台搭建"></a>Hadoop平台搭建</h3><p>&emsp;&emsp;Hadoop有三种安装模式：本地模式安装、伪分布模式安装和完全分布式安装。本文主要介绍Hadoop完全分布式安装，真实环境下都是以这种方式部署（1台Master，2台Slave）。</p><h5 id="部署环境"><a href="#部署环境" class="headerlink" title="部署环境"></a>部署环境</h5><ul><li>Hadoop2.8.5</li><li>VMware14</li><li>ubuntu16.04</li><li>jdk11.01</li></ul><h5 id="第一步：安装ubuntu"><a href="#第一步：安装ubuntu" class="headerlink" title="第一步：安装ubuntu"></a>第一步：安装ubuntu</h5><p>虚拟机的安装教程网上很多，这里不在赘述，注意这里只需要安装一个虚拟机，虚拟机的网络连接方式为NAT。</p><h5 id="第二步：在虚拟机中安装jdk"><a href="#第二步：在虚拟机中安装jdk" class="headerlink" title="第二步：在虚拟机中安装jdk"></a>第二步：在虚拟机中安装jdk</h5><p>我使用的jdk版本是jdk11.01，建议使用jdk1.8。jdk安装完成后需要配置环境变量，jdk的默认安装路径是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/lib/jvm/jdk-11.01</span><br></pre></td></tr></table></figure><p>编辑用户目录下.bashrc文件，在文件末尾添加</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/lib/jvm/jdk-11.01  </span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre  </span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib  </span><br><span class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure><h5 id="第三步：克隆虚拟机"><a href="#第三步：克隆虚拟机" class="headerlink" title="第三步：克隆虚拟机"></a>第三步：克隆虚拟机</h5><p>利用VMware的克隆功能，克隆两个虚拟机</p><h5 id="第四步：修改hostname文件"><a href="#第四步：修改hostname文件" class="headerlink" title="第四步：修改hostname文件"></a>第四步：修改hostname文件</h5><p>现在我们得到三个一模一样的虚拟机，我们选取其中一个虚拟机为Master，其余两个虚拟机分别为Slave。修改Master主机的hostname为Master，两个Slave的hostname分别为Slave1和Slave2，hosts文件的路径为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/hostname</span><br></pre></td></tr></table></figure><h5 id="第五步：配置静态IP"><a href="#第五步：配置静态IP" class="headerlink" title="第五步：配置静态IP"></a>第五步：配置静态IP</h5><p>分别查看三台主机的IP地址，然后修改hosts文件，将三台主机的hostname以及对于的IP添加到hosts文件中，hosts文件路径为，三台主机都要进行同样的操作。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/etc/</span>hosts</span><br></pre></td></tr></table></figure><p>在我的系统中，三台主机的IP如图所示</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/hadoop/hosts.PNG" alt="avatar"></p><h5 id="第六步：建立Hadoop运行账号"><a href="#第六步：建立Hadoop运行账号" class="headerlink" title="第六步：建立Hadoop运行账号"></a>第六步：建立Hadoop运行账号</h5><p>在三台主机上都要建立一个hadoop用户组，并在用户组中添加名为hduser的用户,具体操作如下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd hadoop   #建立hadoop用户组</span><br><span class="line">sudo useradd -s /bin/bash -d /home/hduser -m hduser -g hadoop #添加hduser，指定用户目录</span><br><span class="line">sudo passwd hduser   #修改hduser用户密码</span><br><span class="line">sudo adduser hduser sudo  #赋予hduser管理员权限</span><br><span class="line">su hduser  #切换到hduser用户</span><br></pre></td></tr></table></figure><h5 id="第七步：配置ssh免密登录"><a href="#第七步：配置ssh免密登录" class="headerlink" title="第七步：配置ssh免密登录"></a>第七步：配置ssh免密登录</h5><p>ubuntu默认安装了ssh客户端，但没有安装ssh服务器，配置之前先在三台主机中安装ssh-server</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install</span><br></pre></td></tr></table></figure><p>接着在Master主机中执行如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -P '' -f ~/.ssh/id_rsa  #生成ssh公钥和私钥</span><br><span class="line">cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys  #添加公钥到已认证的key中</span><br></pre></td></tr></table></figure><p>在两台Slave主机中的用户目录下新建.ssh文件夹，然后将Master中的id_rsa.pub文件复制到两台Slave主机的.ssh文件夹下，执行如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys  #添加公钥到已认证的key中</span><br></pre></td></tr></table></figure><p>最后验证是否可以通过Master免密登录两台Slave主机。</p><h5 id="第八步-下载并解压Hadoop"><a href="#第八步-下载并解压Hadoop" class="headerlink" title="第八步:下载并解压Hadoop"></a>第八步:下载并解压Hadoop</h5><p>三台主机都要进行该操作，在用户目录下建立名为hadoop2.8.5的目录，将文件解压到该目录下。</p><h5 id="第九步：修改配置文件"><a href="#第九步：修改配置文件" class="headerlink" title="第九步：修改配置文件"></a>第九步：修改配置文件</h5><p>三台主机都要进行该操作</p><ul><li><p>修改hadoop-env.sh文件,添加JAVA_HOME。（~/hadoop/hadoop2.8.5/etc/hadoop/hadoop-env.sh）</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/hadoop/1.PNG" alt="avatar"></p></li><li><p>修改core-site.cml文件，添加如下内容。（~/hadoop/hadoop2.8.5/etc/hadoop/core-site.cml)</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/hadoop/2.PNG" alt="avatar"></p></li><li><p>修改hdfs-site.xml文件，添加如下内容。（~/hadoop/hadoop2.8.5/etc/hadoop/hdfs-site.xml）</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/hadoop/3.PNG" alt="avatar"></p></li><li><p>修改mapred-site.xml.template文件，添加如下内容。（~/hadoop/hadoop2.8.5/etc/hadoop/mapred-site.xml.template）</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/hadoop/4.PNG" alt="avatar"></p></li><li><p>修改slaves文件，将两台Slave主机名添加进去即可。（~/hadoop/hadoop2.8.5/etc/hadoop/slaves）</p></li><li><p>修改/etc/profile文件，添加如下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/lib/jvm/jdk-11.0.1</span><br><span class="line">export HADOOP_INSTALL=/home/hduser/hadoop/hadoop-2.8.5</span><br><span class="line">export PATH=$PATH:$&#123;HADOOP_INSTALL&#125;/bin:$&#123;HADOOP_INSTALL&#125;/sbin:$&#123;JAVA_HOME&#125;/bin</span><br></pre></td></tr></table></figure><p>然后执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p>检查hadoop是否安装成功</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/hadoop/5.PNG" alt="avatar"></p></li></ul><h5 id="第十步：格式化namenode，并启动集群"><a href="#第十步：格式化namenode，并启动集群" class="headerlink" title="第十步：格式化namenode，并启动集群"></a>第十步：格式化namenode，并启动集群</h5><p>在Master主机中执行以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hadoop namenode -format  #格式化namenode</span><br><span class="line">start-all.ssh  #启动集群</span><br></pre></td></tr></table></figure><p>在ubuntu地址栏中输入http:Master:50070,可以看到Slave结点的相关信息</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/hadoop/hadoop.png" alt="avator"></p>]]></content:encoded>
      
      <comments>https://chaoge123456.github.io/Hadoop%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA.html/#disqus_thread</comments>
    </item>
    
    <item>
      <title>HITB安全峰会之旅.md</title>
      <link>https://chaoge123456.github.io/HITB%E5%AE%89%E5%85%A8%E5%B3%B0%E4%BC%9A%E4%B9%8B%E6%97%85.html/</link>
      <guid>https://chaoge123456.github.io/HITB%E5%AE%89%E5%85%A8%E5%B3%B0%E4%BC%9A%E4%B9%8B%E6%97%85.html/</guid>
      <pubDate>Sun, 04 Nov 2018 14:33:12 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;2018年10月25日，一次偶然的机会在阿里安全响应中心看到了一则新闻-HITB首次走进中国。当时也并没有太在意，因为本身对HITB没有什么印象，在安全领域我关注的会议并不多，比较了解的是BLACKHAT和DEFCON。正好前几天去合
        
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>摘要：</strong>2018年10月25日，一次偶然的机会在阿里安全响应中心看到了一则新闻-HITB首次走进中国。当时也并没有太在意，因为本身对HITB没有什么印象，在安全领域我关注的会议并不多，比较了解的是BLACKHAT和DEFCON。正好前几天去合肥参加了科大讯飞的全球开发者大会，回来之后其实挺失望的（从学术界到产业界都在极力鼓吹“AI”所蕴含的价值，但是却始终看不到实质性的产品和突破，而且很大程度忽视了“AI”所带来的负面影响），当看到这则新闻的时候有感而发，在留言处写下了一点个人的感受。没想到的是，第二天居然收到通知说我的留言被小编抽中了，作为奖励我也免费获得了一张HITB安全峰会的门票。突如其来的惊喜让我有点措手不及，我赶紧上网查了一下关于HITB峰会的相关信息，这才对HITB有了一些了解。作为欧洲三大顶级安全会议之一，HITB一直拥有良好的口碑和技术氛围，我觉得这对我来说是一次很好的机会。之后，我也获得了导师的支持，于是2018年10月30日，我踏上了这次难忘的HITB安全峰会之旅。</p>]]></content:encoded>
      
      <comments>https://chaoge123456.github.io/HITB%E5%AE%89%E5%85%A8%E5%B3%B0%E4%BC%9A%E4%B9%8B%E6%97%85.html/#disqus_thread</comments>
    </item>
    
    <item>
      <title>维吉尼亚加解密及唯密文破解</title>
      <link>https://chaoge123456.github.io/%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E5%8A%A0%E8%A7%A3%E5%AF%86%E5%8F%8A%E5%94%AF%E5%AF%86%E6%96%87%E7%A0%B4%E8%A7%A3.html/</link>
      <guid>https://chaoge123456.github.io/%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E5%8A%A0%E8%A7%A3%E5%AF%86%E5%8F%8A%E5%94%AF%E5%AF%86%E6%96%87%E7%A0%B4%E8%A7%A3.html/</guid>
      <pubDate>Wed, 17 Oct 2018 02:10:22 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt; 古典密码体制主要通过字符间的置换和代换来实现，常见的置换密码包括列置换密码和周期置换密码，而常见的代换密码包括单表代换密码和多表代换密码，本文所讨论的维吉尼亚算法是属于多表代换密码的一种。多表代换密码是以一系列代换表依次对明文消息的字
        
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>摘要</strong> 古典密码体制主要通过字符间的置换和代换来实现，常见的置换密码包括列置换密码和周期置换密码，而常见的代换密码包括单表代换密码和多表代换密码，本文所讨论的维吉尼亚算法是属于多表代换密码的一种。多表代换密码是以一系列代换表依次对明文消息的字母序列进行代换的加密方法，即明文消息中出现的同一个字母，在加密时不是完全被同一固定的字母代换，而是根据其出现的位置次序用不同的字母代换。如果代换表序列是非周期的无限序列，则相应的密码称为非周期多表代换密码，这类密码对每个明文都采用了不同的代换表进行加密，故称为一次一密密码，它是理论上不可破译的密码体制。但实际应用中经常采用的是周期多表代换密码，它通常使用有限个代换表，代换表被重复使用以完成消息的加密。作为多表代换密码的典型代表，维吉尼亚密码算法蕴含着丰富的古典密码设计思想，本文将深入探讨维吉尼亚算法的加解密过程实现，以及利用统计分析的方法进行唯密文攻击。</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/verify/crypt.jpg" alt="avatar"></p><h2 id="文章概览"><a href="#文章概览" class="headerlink" title="文章概览"></a>文章概览</h2><ul><li>维吉尼亚算法简介</li><li>加密算法实现<ul><li>编码方式</li><li>对明文进行处理</li><li>加密过程</li></ul></li><li>解密算法实现</li><li>唯密文攻击<ul><li>确定密钥长度</li><li>确定密钥</li><li>恢复明文</li></ul></li></ul><h3 id="维吉尼亚算法简介"><a href="#维吉尼亚算法简介" class="headerlink" title="维吉尼亚算法简介"></a><a href="https://zh.wikipedia.org/wiki/%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E5%AF%86%E7%A0%81" target="_blank" rel="noopener">维吉尼亚算法简介</a></h3><h3 id="加密算法实现"><a href="#加密算法实现" class="headerlink" title="加密算法实现"></a>加密算法实现</h3><p>&emsp;&emsp;实现加密算法的大致流程是：首先我们需要确定编码方式，本文采用的编码方式是[a-z]对应[0-25]；接着进行加密算法前需要对明文字符串进行处理，删除非字母字符，将大写字符统一转换为小写字母；最后选定密钥对密文中的逐个字符进行加密（即代换操作），生成最后的密文。</p><h4 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h4><p>&emsp;&emsp;本文的字母编码方式由列表s确定，s中每个元素的索引即对应该元素的数字编码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>,<span class="string">'g'</span>,<span class="string">'h'</span>,<span class="string">'i'</span>,<span class="string">'j'</span>,<span class="string">'k'</span>,<span class="string">'l'</span>,<span class="string">'m'</span>,<span class="string">'n'</span>,<span class="string">'o'</span>,<span class="string">'p'</span>,<span class="string">'q'</span>,<span class="string">'r'</span>,<span class="string">'s'</span>,<span class="string">'t'</span>,<span class="string">'u'</span>,<span class="string">'v'</span>,<span class="string">'w'</span>,<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>]</span><br></pre></td></tr></table></figure><h4 id="对明文进行处理"><a href="#对明文进行处理" class="headerlink" title="对明文进行处理"></a>对明文进行处理</h4><p>&emsp;&emsp;对明文进行处理的目的是去除明文中非字母的字符，并将大写字母统一转换为小写字母。转换大小写我们可以使用python字符串内置的lower()函数，稍微有点棘手的是前者，因为在这里需要考虑到一些效率的问题还有如何对后续操作进行优化的问题，比如说:</p><ul><li>读取文件中的明文时我们可以采用read()，readline()，readlines()这三个函数，那我们到底采用哪一个呢？（这三个函数的对比可以参考<a href="https://blog.csdn.net/quiet_girl/article/details/80113591" target="_blank" rel="noopener">这篇博客</a>)</li><li>采用不同读取明文的函数，导致读取结果也不尽相同，有列表形式也有字符串形式，到底哪种形式对后续的操作更有好处</li><li>去掉读取后的明文中的非字母字符应采用何种方式？（逐个字符判断或者正则表达式）</li></ul><p>本文根据文本的实际情况，采用的处理方式如下所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pretreatment</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    pretreatment函数的主要作用是对明文进行预处理，去除非字母字符和转换大小写</span></span><br><span class="line"><span class="string">    :return: 经过预处理的明文字符串</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"plain.txt"</span>,<span class="string">"r"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        wen = f.read()</span><br><span class="line">    pattern = re.compile(<span class="string">'[\n]|\d|\W'</span>)</span><br><span class="line">    plain_1 = re.sub(pattern,<span class="string">''</span>,wen).lower()</span><br><span class="line">    <span class="keyword">return</span> plain_1</span><br></pre></td></tr></table></figure><h4 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h4><p>&emsp;&emsp;维吉尼亚算法的加密过程比较简单，基本思想是利用密钥循环对明文字符进行代换操作，进行代换前将相应的明文字符和密钥字符转化为对应的数字编码，然后相加对26取余即得到对应的密文字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(key)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    encrypt函数的主要作用是进行加密</span></span><br><span class="line"><span class="string">    :param key: 密钥</span></span><br><span class="line"><span class="string">    :return: 密文字符串</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    wen = pretreatment()</span><br><span class="line">    num_key = key_to_num(key)</span><br><span class="line">    ciphertext = <span class="string">''</span></span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> wen:</span><br><span class="line">        <span class="keyword">if</span> k == len(num_key):</span><br><span class="line">            k = <span class="number">0</span></span><br><span class="line">        cipher = change(w,num_key[k])</span><br><span class="line">        cipher = num_to_char(cipher)</span><br><span class="line">        ciphertext = ciphertext + cipher</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">    wirte_txt(ciphertext,<span class="string">'crypt.txt'</span>)</span><br><span class="line">    <span class="keyword">return</span> ciphertext</span><br></pre></td></tr></table></figure><h3 id="解密算法实现"><a href="#解密算法实现" class="headerlink" title="解密算法实现"></a>解密算法实现</h3><p>&emsp;&emsp;解密算法是加密算法的逆过程，进行的代换操作是将密文字符的数字编码减去密钥字符的数字编码，如果相减的结果小于0，则令结果加上26，在转换为对应编码的字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">de_change</span><span class="params">(ch,num)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    de_change函数的作用是根据密文字符和密钥还原明文字符</span></span><br><span class="line"><span class="string">    :param ch: 密文字符</span></span><br><span class="line"><span class="string">    :param num: 密钥编码</span></span><br><span class="line"><span class="string">    :return: 明文字符</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    ch_num = char_to_num(ch)</span><br><span class="line">    result = ch_num - num</span><br><span class="line">    <span class="keyword">if</span> result &lt; <span class="number">0</span>:</span><br><span class="line">        result = <span class="number">26</span> + result</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(key)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    decryption函数的主要作用是将密文解密成明文</span></span><br><span class="line"><span class="string">    :param key: 密钥</span></span><br><span class="line"><span class="string">    :return: 明文</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'crypt.txt'</span>,<span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        ciphertext = f.read()</span><br><span class="line">    num_key = key_to_num(key)</span><br><span class="line">    wen = <span class="string">''</span></span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> ciphertext:</span><br><span class="line">        <span class="keyword">if</span> k == len(num_key):</span><br><span class="line">            k = <span class="number">0</span></span><br><span class="line">        w = de_change(c,num_key[k])</span><br><span class="line">        w = num_to_char(w)</span><br><span class="line">        wen = wen + w</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">    wirte_txt(wen,<span class="string">'result.txt'</span>)</span><br><span class="line">    <span class="keyword">return</span> wen</span><br></pre></td></tr></table></figure><h3 id="唯密文攻击"><a href="#唯密文攻击" class="headerlink" title="唯密文攻击"></a>唯密文攻击</h3><p>&emsp;&emsp;某种语言中各个字符出现的频率不一样而表现出一定的统计规律，而这种统计规律可能在密文中重现，所以我们可以通过统计分析的手段进行一些推测和验证过程来实现对密文的分析。在英文字母中各个字母出现的频率如下所示，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#编码规则</span></span><br><span class="line">s = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>,<span class="string">'g'</span>,<span class="string">'h'</span>,<span class="string">'i'</span>,<span class="string">'j'</span>,<span class="string">'k'</span>,<span class="string">'l'</span>,<span class="string">'m'</span>,<span class="string">'n'</span>,<span class="string">'o'</span>,<span class="string">'p'</span>,<span class="string">'q'</span>,<span class="string">'r'</span>,<span class="string">'s'</span>,<span class="string">'t'</span>,<span class="string">'u'</span>,<span class="string">'v'</span>,<span class="string">'w'</span>,<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>]</span><br><span class="line"><span class="comment">#字母出现频率</span></span><br><span class="line">frequency = [<span class="number">0.082</span>,<span class="number">0.015</span>,<span class="number">0.028</span>,<span class="number">0.043</span>,<span class="number">0.127</span>,<span class="number">0.022</span>,<span class="number">0.02</span>,<span class="number">0.061</span>,<span class="number">0.07</span>,<span class="number">0.002</span>,<span class="number">0.008</span>,<span class="number">0.04</span>,<span class="number">0.024</span>,<span class="number">0.06</span>,<span class="number">0.075</span>,<span class="number">0.019</span>,<span class="number">0.001</span>,<span class="number">0.06</span>,<span class="number">0.063</span>,<span class="number">0.091</span>,<span class="number">0.028</span>,<span class="number">0.01</span>,<span class="number">0.023</span>,<span class="number">0.001</span>,<span class="number">0.02</span>,<span class="number">0.001</span>]</span><br></pre></td></tr></table></figure><p>对于维吉尼亚密码体制来说，我们可以通过统计分析的方法对其密文进行分析，从而获取明文信息。基于维吉尼亚密码体制的唯密文攻击的破解主要包含三个步骤：</p><ul><li>确定密钥长度，常用的方法包括卡西斯基测试法和重合指数法，本文将采用后者进行分析</li><li>确定密钥，常用的方法是拟重合指数法</li><li>根据密文和密钥恢复明文</li></ul><h4 id="确定密钥长度"><a href="#确定密钥长度" class="headerlink" title="确定密钥长度"></a>确定密钥长度</h4><p>&emsp;&emsp;本文采用重合指数法猜解密钥长度，关于重合指数法的具体解释可以参照《现代密码学教程》或者<a href="https://zh.wikipedia.org/wiki/%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E5%AF%86%E7%A0%81" target="_blank" rel="noopener">维基百科</a>，本文主要讲解猜解密钥长度的实现过程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">guess_len_key</span><span class="params">(crypt)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    guess_len_key函数的主要作用是通过密文猜解密钥长度</span></span><br><span class="line"><span class="string">    :param crypt: 密文</span></span><br><span class="line"><span class="string">    :return: 密钥长度以及划为的子串</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    l = <span class="number">1</span></span><br><span class="line">    d = &#123;&#125;</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        print(<span class="string">"****************************假设密钥长度        为%s***********************************"</span> % l)</span><br><span class="line">        sum_index = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(crypt)):</span><br><span class="line">            n = i % l</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                d[n] = <span class="string">''</span></span><br><span class="line">            d[n] += crypt[i]</span><br><span class="line">        sum_index = sum(coincidence_index(d[j]) <span class="keyword">for</span> j <span class="keyword">in</span> range(l)) / l</span><br><span class="line">        <span class="keyword">if</span> sum_index &gt;= <span class="number">0.06</span> <span class="keyword">and</span> sum_index &lt;= <span class="number">0.07</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">            d = &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> l,d</span><br></pre></td></tr></table></figure><p>该算法的主要思想是将密文划分为l个子串，子串存放在字典d中。分别计算l个子串的重合指数，然后计算l个重合指数的平均数，如果该平均数位于[0.06,0.07]这个区间内，则说明密钥长度为l，返回密钥长度以及划分的l个子串；如果得到的平均数不在[0.06,0.07]这个区间内，则l自增，d初始化，进行下一轮猜解。</p><h4 id="确定密钥"><a href="#确定密钥" class="headerlink" title="确定密钥"></a>确定密钥</h4><p>&emsp;&emsp;确定密钥长度大致过程是：利用之前得到的l个子串，对每个子串都进行移位操作。假设现在对第i个子串进行移位操作（子串的每个字符移动相同的位数，最坏情况下对同一个子串需要进行26次移位操作），移动的位数为k,（k在[0-25]区间内，也就对应了[a-z]）。每进行一次移位操作，就对该子串计算一次拟重合指数，如果该拟重合指数位于[0.06,0.07]这个区间内，则说明此时移动的位数对应的s列表中的字符即为该子串的密钥；否则，继续进行下一次移位操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_key</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    cracker函数的主要作用是破解密钥</span></span><br><span class="line"><span class="string">    :return: 返回密钥</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"crypt.txt"</span>,<span class="string">"r"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        crypt = f.read()</span><br><span class="line">    len_key,d = guess_len_key(crypt)</span><br><span class="line">    key = <span class="string">''</span></span><br><span class="line">    print(<span class="string">"\n-------------------------------------"</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"|       经计算可知，密钥长度为%s         |"</span> % len_key)</span><br><span class="line">    print(<span class="string">"-------------------------------------\n"</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len_key):</span><br><span class="line">        substring = d[i]</span><br><span class="line">        print(<span class="string">"当前字串为："</span>,d[i])</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">26</span>):</span><br><span class="line">            dex = quasi_index(substring, n)</span><br><span class="line">            print(<span class="string">"假设子串移动&#123;&#125;,拟重合指数为&#123;:.4f&#125;"</span>.format(s[n],dex))</span><br><span class="line">            <span class="keyword">if</span> dex &gt;= <span class="number">0.06</span> <span class="keyword">and</span> dex &lt;= <span class="number">0.07</span>:</span><br><span class="line">                key += s[n]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    print(<span class="string">"******************************破解的最终密钥为%s*********************************"</span> % key)</span><br></pre></td></tr></table></figure><h4 id="恢复明文"><a href="#恢复明文" class="headerlink" title="恢复明文"></a>恢复明文</h4><p>&emsp;&emsp;恢复明文的过程与解密过程类似，这里不在详述。</p><h3 id="系统运行演示"><a href="#系统运行演示" class="headerlink" title="系统运行演示"></a>系统运行演示</h3><h4 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h4><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/verify/jiami.PNG" alt="avatar"></p><h4 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h4><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/verify/jiemi.PNG" alt="avatar"></p><h4 id="猜解密钥长度"><a href="#猜解密钥长度" class="headerlink" title="猜解密钥长度"></a>猜解密钥长度</h4><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/verify/keylen.PNG" alt="avatar"></p><h4 id="猜解密钥"><a href="#猜解密钥" class="headerlink" title="猜解密钥"></a>猜解密钥</h4><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/verify/nichonghe.PNG" alt="avatar"></p>]]></content:encoded>
      
      <comments>https://chaoge123456.github.io/%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E5%8A%A0%E8%A7%A3%E5%AF%86%E5%8F%8A%E5%94%AF%E5%AF%86%E6%96%87%E7%A0%B4%E8%A7%A3.html/#disqus_thread</comments>
    </item>
    
    <item>
      <title>raspberry入门配置</title>
      <link>https://chaoge123456.github.io/raspberry%E5%85%A5%E9%97%A8%E9%85%8D%E7%BD%AE.html/</link>
      <guid>https://chaoge123456.github.io/raspberry%E5%85%A5%E9%97%A8%E9%85%8D%E7%BD%AE.html/</guid>
      <pubDate>Sat, 22 Sep 2018 12:53:38 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt; 最近准备在树莓派上搭建一个智能家居系统，更新系统的过程中不知道什么原因导致系统崩了，我的心顿时凉了半截。查阅了很多资料，没找到解决方法，只能重装系统（基于stretch版本）了。虽然之前的系统也是自己一步步配置的，但是这次重新配置的过
        
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>摘要</strong> 最近准备在树莓派上搭建一个智能家居系统，更新系统的过程中不知道什么原因导致系统崩了，我的心顿时凉了半截。查阅了很多资料，没找到解决方法，只能重装系统（基于stretch版本）了。虽然之前的系统也是自己一步步配置的，但是这次重新配置的过程中还是遇到了很多问题，在这里记录一下，希望能给小伙伴们一些启发。</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/raspberry/images.png" alt="avatar"></p><h2 id="文章概览"><a href="#文章概览" class="headerlink" title="文章概览"></a>文章概览</h2><ul><li>重新安装系统</li><li>连接树莓派</li><li>安装远程桌面服务</li><li>更新软件源</li><li>raspi-config</li><li>配置无线网络</li><li>配置静态IP</li><li>配置内网映射</li><li>安装zsh</li><li>python环境搭建</li></ul><h3 id="重新安装系统"><a href="#重新安装系统" class="headerlink" title="重新安装系统"></a>重新安装系统</h3><p>&emsp;&emsp;重新安装系统的过程我们需要用到：<a href="https://www.raspberrypi.org/downloads/" target="_blank" rel="noopener">系统镜像</a>、<a href="http://www.diskgenius.cn/" target="_blank" rel="noopener">DiskGenius</a>、<a href="#https://sourceforge.net/projects/win32diskimager/">Win32DiskImager</a>，DiskGenius的作用是格式化TF卡，Win32DiskImager的作用是将系统镜像写入TF卡，具体的操作过程可以参考<a href="https://www.jianshu.com/p/6af60049fdf1" target="_blank" rel="noopener">这篇博客</a>。</p><h3 id="连接树莓派"><a href="#连接树莓派" class="headerlink" title="连接树莓派"></a>连接树莓派</h3><p>&emsp;&emsp;对于如何连接树莓派，我在之前的博客中详细的讨论过，这里不再赘述，需要提醒大家的是只需要使用某一种方法连接树莓派即可。</p><h3 id="安装远程连接服务"><a href="#安装远程连接服务" class="headerlink" title="安装远程连接服务"></a>安装远程连接服务</h3><p>&emsp;&emsp;ssh连接是通过命令行对树莓派进行远程操作，而远程桌面是直接通过树莓派的GUI界面进行操作，操作简单，交互性好。xrdp是一个开源的远程桌面服务器，支持windows远程桌面连接，但是需要使用tightvncserver作为其基础服务，具体安装操作如下所示。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update #更新</span><br><span class="line">sudo apt-get install xrdp</span><br><span class="line">sudo apt-get install tightvncserver</span><br></pre></td></tr></table></figure><p>安装好以上两个服务以后。可以使用windows自带的远程连接工具连接到树莓派。</p><h3 id="更新软件源"><a href="#更新软件源" class="headerlink" title="更新软件源"></a>更新软件源</h3><p>&emsp;&emsp;在更新软件源的时候，大家注意查看自己的系统版本（推荐大家安装最新的系统版本），具体操作参见<a href="https://mirror.tuna.tsinghua.edu.cn/help/" target="_blank" rel="noopener">清华大学开源软件镜像站</a>。</p><h3 id="raspi-config"><a href="#raspi-config" class="headerlink" title="raspi-config"></a>raspi-config</h3><p>&emsp;&emsp;通过远程桌面连接到树莓派之后，系统会提示进行一些初始化配置，包括拓展内存、设置时区、语言等等，具体操作参见<a href="http://shumeipai.nxez.com/2013/09/07/raspi-config-configuration-raspberry-pie.html" target="_blank" rel="noopener">这篇博客</a>。</p><h3 id="配置无线网络"><a href="#配置无线网络" class="headerlink" title="配置无线网络"></a>配置无线网络</h3><p>&emsp;&emsp;配置无线网络有两种方式，一个是在图形化界面直接选择连接的ssid，输入密码即可，系统会保存该无线网络的相关信息到/etc/wpa_supplicant/wpa_supplicant.conf文件；另外一种方式是直接修改该配置文件，将无线网络配置信息添加到该文件中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">country=CN</span><br><span class="line">ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev</span><br><span class="line">update_config=1</span><br><span class="line"></span><br><span class="line">network=&#123;</span><br><span class="line">    ssid="***"</span><br><span class="line">    psk="***"</span><br><span class="line">    priority=1</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="配置静态IP"><a href="#配置静态IP" class="headerlink" title="配置静态IP"></a>配置静态IP</h3><p>&emsp;&emsp;由于每次树莓派连接路由器的时候，路由器会分配不同的IP地址，所以当我们连接树莓派的时候每次都要通过路由器查看树莓派的IP地址，这样比较麻烦，所以，我们需要给路由器指定静态的IP。修改/etc/dhcpcd.conf文件（一定要注意不是修改/etc/network/interfaces文件），在后面添加以下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface eth0 #有线</span><br><span class="line"> </span><br><span class="line">static ip_address=192.168.0.10/24</span><br><span class="line">static routers=192.168.0.1</span><br><span class="line">static domain_name_servers=192.168.0.1</span><br><span class="line"> </span><br><span class="line">interface wlan0 #无线连接</span><br><span class="line"> </span><br><span class="line">static ip_address=192.168.0.200/24</span><br><span class="line">static routers=192.168.0.1</span><br><span class="line">static domain_name_servers=192.168.0.1</span><br></pre></td></tr></table></figure><h3 id="配置内网映射"><a href="#配置内网映射" class="headerlink" title="配置内网映射"></a>配置内网映射</h3><p>&emsp;&emsp;如果想要从外网直接访问树莓派，那我们需要将树莓派的内网IP映射到公网当中，这里我们使用的映射工具是花生壳，具体操作参见<a href="http://service.oray.com/question/2680.html" target="_blank" rel="noopener">官方教程</a>。</p><h3 id="安装zsh"><a href="#安装zsh" class="headerlink" title="安装zsh"></a>安装zsh</h3><p>&emsp;&emsp;树莓派基于linux操作系统，其终端shell默认的是bash，而zsh是比bash更加强大的shell，而且更加美观，具体配置参见<a href="https://mlapp.cn/310.html" target="_blank" rel="noopener">这篇博客</a>。</p><h3 id="python环境搭建"><a href="#python环境搭建" class="headerlink" title="python环境搭建"></a>python环境搭建</h3><p>&emsp;&emsp;树莓派中内置了两个版本的python，python2.7和python3.5，系统默认版本为python2.7。在进行系统环境配置和相关依赖安装的过程中，一律使用系统默认版本即python2.7（如果切换至python3.5.会出现各种各样的问题）。在程序开发过程中如果需要使用python3.5，可以切换python环境，具体操作参见<a href="https://linux.cn/article-6970-1.html" target="_blank" rel="noopener">这篇博客</a>。</p>]]></content:encoded>
      
      <comments>https://chaoge123456.github.io/raspberry%E5%85%A5%E9%97%A8%E9%85%8D%E7%BD%AE.html/#disqus_thread</comments>
    </item>
    
    <item>
      <title>如何连接树莓派</title>
      <link>https://chaoge123456.github.io/%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5%E6%A0%91%E8%8E%93%E6%B4%BE.html/</link>
      <guid>https://chaoge123456.github.io/%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5%E6%A0%91%E8%8E%93%E6%B4%BE.html/</guid>
      <pubDate>Thu, 13 Sep 2018 12:08:02 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt; 早就听说了树莓派的大名，什么智能家居，智能机器人，无人机等等它都不在话下。我最近刚刚入手了一款树莓派3B+，想利用它来开发一个智能家居的控制系统。由于从来没有接触过相关的硬件，在配置过程中确实遇到了不少坑，在这里简单的记录一下，希望能
        
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>摘要</strong> 早就听说了树莓派的大名，什么智能家居，智能机器人，无人机等等它都不在话下。我最近刚刚入手了一款树莓派3B+，想利用它来开发一个智能家居的控制系统。由于从来没有接触过相关的硬件，在配置过程中确实遇到了不少坑，在这里简单的记录一下，希望能给读者一些启发。本文主要讲解如何连接树莓派的问题。</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/raspberry/shumei.jpg" alt="avatar"></p><h2 id="文章概览"><a href="#文章概览" class="headerlink" title="文章概览"></a>文章概览</h2><ul><li>基本配置</li><li>系统安装</li><li>连接树莓派<ul><li>有路由器和网线的情况下</li><li>有网线没有路由器的情况下</li><li>没有路由器没有网线的情况下</li></ul></li></ul><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p>&emsp;&emsp;想要玩树莓派，仅仅买一块主板是不够的，基本的配置包括：一块主板（大概225RMB）、一个读卡器（大概10RMB）、一根电源线（大概8RMB）、一张大于8G的内存卡（我买的是32G的，38RMB）、散热片（大概5RMB）和一个保护外壳（大概20RMB），推荐大家主板和配件分开买，这样比较划算。</p><h3 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h3><p>&emsp;&emsp;树莓派的安装过程比较简单，首先我们需要下载准备安装的系统镜像，在<a href="#https://www.raspberrypi.org/downloads/">树莓派官网</a>可以下载到相关的镜像文件，树莓派支持的系统很多，包括ubuntu、kail、win10等等。我选择的系统是树莓派官方推荐的RSAPBIAN，基于Debian，稳定兼容性好。然后我们需要下载一款工具：<a href="#http://sourceforge.net/projects/win32diskimager/files/latest/download">win32diskimager</a>，我们需要利用这款工具将树莓派的系统镜像写入内存卡。</p><p>&emsp;&emsp;准备工作完成后，我们通过读卡器将内存卡接入电脑，在利用win32diskmager工具将系统镜像写入内存卡（这个过程很简单，这里不再详细解释）。镜像写入完成之后，我们的系统就成功的安装到内存卡中。但是，有一个问题需要我们注意，镜像写入完成后系统会弹出一个对话框，大概的意思是：无法识别内存卡中的数据，是否要将内存卡格式化，这个时候大家一定选择否或者直接关闭对话框。因为系统写入完成之后，我们的主机只能读出内存卡中系统的boot分区（大概只有40多MB），内存卡中的其他分区我们的系统识别不出来，所以才会弹出这个对话框，一旦我们选择格式化，刚才安装的系统会被删除。如果有小伙伴不小心选择了格式化，那就只有重新安装系统了，大家可以参考<a href="#https://www.jianshu.com/p/6af60049fdf1">这篇博客</a>。</p><p>&emsp;&emsp;还有一个需要注意的问题是，树莓派默认没有开启ssh服务，所以之后我们如果需要通过ssh连接树莓派时，我们需要在刚刚写入系统的内存卡的boot文件夹下，建立一个文件名为ssh的空文件（无后缀名），这样在之后的操作中我们就能通过ssh连接树莓派。</p><h3 id="连接树莓派"><a href="#连接树莓派" class="headerlink" title="连接树莓派"></a>连接树莓派</h3><p>&emsp;&emsp;连接树莓派最简单的方法就是通过HDMI数据线连接显示屏，这样我们可以直接通过显示屏对树莓派进行操作。那如果我们没有显示屏，我们该如何连接树莓派呢？</p><h4 id="有路由器和网线的情况下"><a href="#有路由器和网线的情况下" class="headerlink" title="有路由器和网线的情况下"></a>有路由器和网线的情况下</h4><p>&emsp;&emsp;这种情况下连接树莓派也比较简单，我们只需要将网线的一端接入路由器的lan接口，一端接入树莓派的网络接口（树莓派会自动获取IP地址），同时我们的主机也连接在路由器所建立的局域网内，此时我们可以通过路由器查看树莓派的IP地址。获取树莓派IP地址之后，我们通过主机中的xshell或者putty等远程连接工具就可以连接到树莓派。</p><h4 id="有网线没有路由器的情况下"><a href="#有网线没有路由器的情况下" class="headerlink" title="有网线没有路由器的情况下"></a>有网线没有路由器的情况下</h4><p>&emsp;&emsp;没有了路由器，树莓派就不能获取到IP地址，这种情况稍微复杂一点。解决办法是：将网线的两端连接树莓派和主机，然后我们打开主机的网络和共享中心</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/raspberry/1.PNG" alt="avatar"></p><p>点击我们已经连接的网络，查看其属性</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/raspberry/2.PNG" alt="avatar"></p><p>点击共享按钮，勾选允许其他网络用户通过此计算机的Internet连接来连接（N）</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/raspberry/3.PNG" alt="avatar"></p><p>接下来我们回到网络和共享中心，点击未识别的网络那一栏对于的以太网选项，查看其详细信息，可以看到其IP地址，这里的IP为192.168.137.1</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/raspberry/4.PNG" alt="avatar"></p><p>然后我们拔掉网线，关掉树莓派，拔出内存卡，将其通过读卡器连接到主机上。我们进入内存卡的boot文件夹，修改comline.txt文件，将 ip = 192.168.137.100 这句话添加到开头。完成上述步骤之后，我们将内存卡插入树莓派，用网线重新连接树莓派和主机，启动树莓派电源。我们通过远程连接工具连接树莓派，此时树莓派的IP地址为刚才设置的192.168.137.100，不出意外的话，我们也能连接上树莓派。</p><h4 id="没有路由器没有网线的情况下"><a href="#没有路由器没有网线的情况下" class="headerlink" title="没有路由器没有网线的情况下"></a>没有路由器没有网线的情况下</h4><p>&emsp;&emsp;要使我们的主机能够远程连接到树莓派上，我们必须满足一个条件：主机和树莓派位于同一个局域网。没有路由器和网线的情况下，我们可以通过手机热点建立一个局域网环境，让树莓派和主机同时连接手机热点。现在需要解决的问题是如何才能让树莓派连接上手机的热点。开机状态下，树莓派的无线模块一直处于工作状态，我们需要将无线热点的相关配置文件写入系统。同样，我们通过读卡器读取内存卡boot文件夹，在文件夹下新建文件名为wpa_supplicant.conf的文件，在文件内写入手机热点的配置信息并保存。</p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/raspberry/5.PNG" alt="avatar"></p><p>然后重新插入内存卡，开启树莓派，在手机上查看树莓派的IP地址，用远程连接工具进行连接。</p>]]></content:encoded>
      
      <comments>https://chaoge123456.github.io/%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5%E6%A0%91%E8%8E%93%E6%B4%BE.html/#disqus_thread</comments>
    </item>
    
    <item>
      <title>解释型语言python</title>
      <link>https://chaoge123456.github.io/%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80python.html/</link>
      <guid>https://chaoge123456.github.io/%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80python.html/</guid>
      <pubDate>Mon, 10 Sep 2018 15:14:35 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt; 计算机不能直接理解高级语言，只能直接理解机器语言，所以必须要把高级语言翻译成机器语言，计算机才能执行高级语言编写的程序。由于翻译方式的不同，习惯上我们大致把高级语言分为两类，即编译型语言和解释型语言。对于这两种类型的编程语言，很多人在
        
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>摘要</strong> 计算机不能直接理解高级语言，只能直接理解机器语言，所以必须要把高级语言翻译成机器语言，计算机才能执行高级语言编写的程序。由于翻译方式的不同，习惯上我们大致把高级语言分为两类，即编译型语言和解释型语言。对于这两种类型的编程语言，很多人在理解层面上存在盲点，本文将对这两种类型的编程语言进行探讨，帮助读者更好的理解这一问题。</p><h2 id="文章概览"><a href="#文章概览" class="headerlink" title="文章概览"></a>文章概览</h2><ul><li><p>编译型语言和解释型语言</p><ul><li>基本解释</li><li>优缺点</li></ul></li><li><p>python</p><ul><li>python解释器</li><li>python代码执行过程</li></ul></li></ul><h3 id="编译型语言和解释型语言"><a href="#编译型语言和解释型语言" class="headerlink" title="编译型语言和解释型语言"></a>编译型语言和解释型语言</h3><h4 id="基本解释"><a href="#基本解释" class="headerlink" title="基本解释"></a>基本解释</h4><p>&emsp;&emsp;对于编译型语言，我们以C语言为例，C语言在执行过程中，先要将源程序编译为目标文件（机器代码），该目标文件是与平台相关的，也就是说ARM生成的目标文件，不能被用于MIPS的CPU，也不能用于x86的CPU。目标文件经过连接操作就可以生成可执行文件，以后我们想再次运行这段代码时，不必进行编译操作，只需要直接执行生成的可执行文件即可。</p><p>&emsp;&emsp;对于解释型语言呢，我们不需要执行编译过程，程序在执行时直接由解释器逐句地对程序进行解释，转换为机器可以执行的代码。但是对于有些解释型语言来说，也需要进行编译操作，比如Java。Java程序在执行过程中先要将源代码编译成字节码文件，然后再由解释器对字节码文件逐句进行解释，所以说Java是一种先编译后解释的语言。（注：Java为了实现跨平台的特性，专门在从高级语言代码转换至机器码过程的中间加入了一层中间层JVM（java虚拟机），Java首先依赖编译器将代码（.java）编译成JVM能识别的字节码文件（.class），然后由JVM解释并执行该字节码，也可结合JIT（just-in-time compilation即时编译）技术，将解释生成的机器码转换为更高效的本地机器码，且该机器码可被缓存，来提高重复执行的效率。)</p><p>&emsp;&emsp;常见的编译型语言包括：C/C++、Pascal等，常见的编译型语言包括：Java、JavaScript、VBScript、Perl、Ruby、MATLAB 等。</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>编译型语言可以做到一次编译，多次运行，执行效率比较高；而解释型语言在每次执行时都需要解释器进行解释，执行效率较低（但是我们也不能一概而论，一些解释型语言也可以通过解释器的优化来在对程序做出翻译时对整个程序做出优化，从而在效率上超过编译型语言）。</li><li>编译型语言的执行依赖于平台，生成的可执行文件不能运行在其他平台，需重新编译，跨平台的性较差；而解释型语言的执行依赖于解释器，各个平台都有相应的解释器，解释器会将程序解释成基于当前机器指令集的机器码并执行，所以解释型语言可以很好的移植到其他平台，具有很好的跨平台性。</li><li>编译型语言，在编译阶段即可发现常见的语法或者链接等错误，此机制可在运行前帮助程序员排查出可能潜在的语法、语义和类型转换错误，编译型语言一般都有明确的变量类型检测，也被称作<strong>强类型语言</strong>，即编译型语言至少能确保所生成的可执行文件肯定是可运行的，至于执行的逻辑不对则属于程序员业务逻辑错误范畴了。而对于解释型语言，代码中的错误必须直到运行阶段方可发现，由此造成的困惑是：往往一段程序看不出问题但却在运行阶段错误连连且需要一个个排查：变量拼写错误、方法不存在等。但也正是基于解释是在运行期执行转化的特性，一般的解释型语言通常都有自己的shell，可以在不确定某些执行结果时立即“动手执行”试一下，这就比每次都需要编译后才能运行并看到结果省去不少时间。</li></ul><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><p>&emsp;&emsp;通过上面对编译型语言和解释型语言的分析，我们可以得出结论，python是属于解释型语言的一种。python类似于Java，为了效率上的考虑，也提供了编译方式，编译后生成的也是字节码的文件形式，并由Python的的VM（虚拟机）的去执行。不同点在于，Python的编译并非强制执行的操作，确切来说Python的编译是自动的，通常发生在对某个模块（module）的调用过程中，编译成字节码的可以节省加载模块的时间，以此达到提高效率的目的。可见，某些先进的高级语言在对编译和解释方面的拿捏舍去，都采取了一种：两手抓，两手都要硬的态度。</p><h4 id="python解释器"><a href="#python解释器" class="headerlink" title="python解释器"></a>python解释器</h4><p>&emsp;&emsp;由于整个Python语言从规范到解释器都是开源的，所以理论上，只要水平够高，任何人都可以编写Python解释器来执行Python代码（当然难度很大）。事实上，确实存在多种Python解释器</p><ul><li>CPython:  这个解释器是用C语言开发的，所以叫CPython。在命令行下运行python就是启动CPython解释器,它是使用最广的Python解释器.</li><li>IPython是基于CPython之上的一个交互式解释器，也就是说，IPython只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的。CPython用<code>&gt;&gt;&gt;</code>作为提示符，而IPython用<code>In [序号]:</code>作为提示符。</li><li>绝大部分Python代码都可以在PyPy下运行，但是PyPy和CPython有一些是不同的，这就导致相同的Python代码在两种解释器下执行可能会有不同的结果。PyPy是另一个Python解释器，它的目标是执行速度。PyPy采用<a href="http://en.wikipedia.org/wiki/Just-in-time_compilation" target="_blank" rel="noopener">JIT技术</a>，对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。</li><li>Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。</li></ul><h4 id="python代码执行过程"><a href="#python代码执行过程" class="headerlink" title="python代码执行过程"></a>python代码执行过程</h4><p>&emsp;&emsp;参考这篇<a href="https://blog.csdn.net/helloxiaozhe/article/details/78104975" target="_blank" rel="noopener">博客</a>和这篇<a href="https://www.cnblogs.com/kym/archive/2012/05/14/2498728.html" target="_blank" rel="noopener">博客</a></p>]]></content:encoded>
      
      <comments>https://chaoge123456.github.io/%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80python.html/#disqus_thread</comments>
    </item>
    
    <item>
      <title>决策树算法详解与python实现：ID3和CART</title>
      <link>https://chaoge123456.github.io/%E5%86%B3%E7%AD%96%E6%A0%91.html/</link>
      <guid>https://chaoge123456.github.io/%E5%86%B3%E7%AD%96%E6%A0%91.html/</guid>
      <pubDate>Sun, 09 Sep 2018 07:12:47 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt; 决策树是一种基本的分类与回归方法，本文主要讨论用于分类的决策树，决策树模型呈树形结构，在分类问题中，表示基于特征对实例进行分类的过程，它可以认为是if-then规则的集合，也可以认为是定义在特征空间与类空间上的条件概率分布，其主要优点
        
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>摘要</strong> 决策树是一种基本的分类与回归方法，本文主要讨论用于分类的决策树，决策树模型呈树形结构，在分类问题中，表示基于特征对实例进行分类的过程，它可以认为是if-then规则的集合，也可以认为是定义在特征空间与类空间上的条件概率分布，其主要优点是模型具有可读性，分类速度快。学习时，利用训练数据，根据损失函数最小化原则建立决策树模型。预测时，对新的数据，利用决策树模型进行分类。决策树学习通常包括三个步骤：特征选择、决策树的生成以及决策树的修剪。本文将主要讲解ID3和CART算法的原理和实现细节。  </p><p><img src="https://githubpage-1255710107.cos.ap-shanghai.myqcloud.com/static/images/verify/tree.png" alt="avatar"></p><h2 id="文章概览"><a href="#文章概览" class="headerlink" title="文章概览"></a>文章概览</h2><ul><li>ID3算法<ul><li>特征选择</li><li>决策树的生成</li><li>ID3算法的缺陷</li><li>C4.5算法对ID3算法的改进</li></ul></li><li>CART算法<ul><li>特征选择</li><li>决策树生成</li><li>剪枝</li></ul></li></ul><h3 id="ID3算法"><a href="#ID3算法" class="headerlink" title="ID3算法"></a>ID3算法</h3><p>&emsp;&emsp;ID3算法是由澳大利亚计算机科学家Ross Quinlan提出的，它是构建决策树中一种非常重要的算法。在设计算法的过程中，它首次采用了信息增益准则来进行特征选择，这很大程度上推动了决策树算法的发展。</p><h4 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h4><p>&emsp;&emsp;我们可以将决策树看作是if- then规则的集合，使用决策树模型进行预测的过程就相当于对if - then规则进行判断，那我们可以想到如果if -then规则越多，也就是决策树越复杂，那么预测所需要的时间越长，所以为了不断优化决策树的决策过程，我们需要合理的构建决策树，那么如何来选择if - then的决策规则至关重要。</p><p>&emsp;&emsp;在ID3算法中，我们通过信息增益作为决策规则。信息增益 = 信息熵 - 条件熵，信息熵代表随机变量的不确定度，条件熵代表在一定条件下，随机变量的复杂度，所以信息增益表示在一定条件下信息复杂度减少的程度。信息增益越大说明该决策规则的区分度越高，在构建决策树时，我们选取信息增益最大的特征作为决策规则。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">emp_entropy</span><span class="params">(y_data)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    emp_entropy函数的主要功能是计算数据集的经验熵</span></span><br><span class="line"><span class="string">    :param y_data: 数据集的类别</span></span><br><span class="line"><span class="string">    :return: 返回数据集的经验熵</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    count = &#123;&#125;</span><br><span class="line">    emp = <span class="number">0.0</span></span><br><span class="line">    m = len(y_data)</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> y_data:</span><br><span class="line">        <span class="keyword">if</span> y <span class="keyword">in</span> count:</span><br><span class="line">            count[y] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            count[y] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> count.keys():</span><br><span class="line">        info = (<span class="number">1.0</span> * count[i] / m)</span><br><span class="line">        emp = emp + info * math.log(info,<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> emp</span><br></pre></td></tr></table></figure><p>emp_entropy函数的主要功能是计算数据集合的经验熵，经验熵的计算公式可以参考《统计学习方法》，同样，下面涉及到条件熵、信息增益的计算公式也可参考本书。代码中字典count的主要作用是统计数据集中不同类别出现的次数，emp即是信息增益。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">emp_cond_entropy</span><span class="params">(x_data,y_data,feature)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    emp_cond_entropy函数的主要作用是计算经验条件熵</span></span><br><span class="line"><span class="string">    :param x_data: 数据集</span></span><br><span class="line"><span class="string">    :param y_data: 数据集类别</span></span><br><span class="line"><span class="string">    :param feature: 数据集特征特征</span></span><br><span class="line"><span class="string">    :return: 数据集的经验条件熵</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    count_y = &#123;&#125;</span><br><span class="line">    emp_cond = <span class="number">0.0</span></span><br><span class="line">    m = len(y_data)</span><br><span class="line">    fea = x_data[:,feature]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(fea)):</span><br><span class="line">        <span class="keyword">if</span> fea[i] <span class="keyword">in</span> count_y:</span><br><span class="line">            count_y[fea[i]].append(y_data[i])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            count_y.setdefault(fea[i])</span><br><span class="line">            count_y[fea[i]] = []</span><br><span class="line">            count_y[fea[i]].append(y_data[i])</span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> count_y.keys():</span><br><span class="line">        l = len(count_y[e])</span><br><span class="line">        emp_cond = emp_cond + (<span class="number">1.0</span> * l / m) * emp_entropy(count_y[e])</span><br><span class="line">    <span class="keyword">return</span> emp_cond</span><br></pre></td></tr></table></figure><p>emp_cond_entropy函数的主要作用是计算经验条件熵，fenture表示数据的某一维特征，对于离散性特征（ID3算法不能处理连续型特征）来讲，特征的取值有多个，这里的count_y就是来统计该特征中不同取值的数据分布情况，列表fea表示的即是该数据集中该特征对应的值，emp_cond表示的是将该特征作为决策规则时的条件熵。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">choose_feature</span><span class="params">(x_data,y_data)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    choose_feature函数的主要作用是从数据集中选择信息增益最大的特征</span></span><br><span class="line"><span class="string">    :param x_data: 数据集</span></span><br><span class="line"><span class="string">    :param y_data: 数据集类别</span></span><br><span class="line"><span class="string">    :return: 信息增益最大的特征</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    n = np.size(x_data,<span class="number">1</span>)</span><br><span class="line">    count = []</span><br><span class="line">    emp = emp_entropy(y_data)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        emp_cond = emp_cond_entropy(x_data,y_data,i)</span><br><span class="line">        count.append(emp - emp_cond)</span><br><span class="line">    feature = count.index(min(count))</span><br><span class="line">    <span class="keyword">return</span> feature</span><br></pre></td></tr></table></figure><p>choose_feature函数的主要作用是从数据集中选择信息增益最大的特征，算法的思路就是对数据集进行遍历，计算每一个特征的信息增益，返回信息增益最大的特征。（由于在计算经验熵的过程中没有添加负号，所以我这里取的是负数的最小值，也就是正数的最大值）</p><h4 id="决策树的生成"><a href="#决策树的生成" class="headerlink" title="决策树的生成"></a>决策树的生成</h4><p>&emsp;&emsp;特征树的生成过程其实是一个递归过程，我们首先选择一个特征，作为根结点，根据根结点的不同取值，将数据集分为几个不同的部分，同时将该特征从数据集中删除。然后再对这几个不同的部分进行同样的操作，直到数据集类别相同或者没有特征为止。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_tree</span><span class="params">(x_data,y_data,feature_list_data)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    create_tree函数的主要作用是构建决策树</span></span><br><span class="line"><span class="string">    :param x_data:</span></span><br><span class="line"><span class="string">    :param y_data:</span></span><br><span class="line"><span class="string">    :param feature_list:</span></span><br><span class="line"><span class="string">    :return: 返回决策树</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    feature_list = feature_list_data[:]</span><br><span class="line">    <span class="keyword">if</span> is_all_same(y_data):</span><br><span class="line">        <span class="keyword">return</span> y_data[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> len(x_data) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> node_classfy(y_data)</span><br><span class="line">    feature = choose_feature(x_data,y_data)</span><br><span class="line">    node_name = feature_list[feature]</span><br><span class="line">    tree = &#123;node_name:&#123;&#125;&#125;</span><br><span class="line">    <span class="keyword">del</span> feature_list[feature]</span><br><span class="line">    count_x,count_y = feature_split(x_data,y_data,feature)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> count_x.keys():</span><br><span class="line">        fealist = feature_list[:]</span><br><span class="line">        count_x_del = del_feature(count_x[i],feature)</span><br><span class="line">        tree[node_name][i] = create_tree(count_x_del,count_y[i],fealist)</span><br><span class="line">    <span class="keyword">return</span> tree</span><br></pre></td></tr></table></figure><p>feature_list的作用是复制feature_list_data，因为后面要进行删除操作，我们要保证删除操作只能影响函数内部变量，不能对函数的实参造成影响。我们生成的决策树保存在tree字典中，每执行一次递归操作，相当于将当前特征作为一个字典的key，递归操作返回的即是一个子树（即字典）。</p><h4 id="ID3算法的缺陷"><a href="#ID3算法的缺陷" class="headerlink" title="ID3算法的缺陷"></a>ID3算法的缺陷</h4><p>&emsp;&emsp;通过对ID3算法进行分析，我们可以知道，ID3算法主要存在以下缺陷：</p><ul><li>ID3没有考虑连续型特征，数据集的特征必须是离散型特征</li><li>ID3算法采用信息增益大的特征优先建立决策树的结点，但是再计算信息增益的过程中我们发现，在相同条件下，取值比较多的特征比取值少的特征信息增益大</li><li>ID3没有对缺失值情况进行处理，现实任务中常会遇到不完整的样本，即样本的某些属性值缺失。</li><li>没有考虑过拟合问题</li></ul><h4 id="C4-5算法对ID3算法的改进"><a href="#C4-5算法对ID3算法的改进" class="headerlink" title="C4.5算法对ID3算法的改进"></a>C4.5算法对ID3算法的改进</h4><p>&emsp;&emsp;C4.5算法是对ID3算法存在的缺陷进行改进的一种算法，它通过将连续特征离散化来解决ID3算法不能处理离散型数据的问题（这个会在后面的CART算法中讲到）；通过引入信息增益比来解决信息增益的缺陷；通过增加剪枝操作来解决过拟合的问题。</p><h3 id="CART算法"><a href="#CART算法" class="headerlink" title="CART算法"></a>CART算法</h3><p>&emsp;&emsp;CART算法是一种应用广泛的决策树算法，它的基本流程与C4.5算法类似，它既可以应用于回归任务，也可以应用于分类任务（这里主要讲解分类树），需要注意的是CART算法生成的决策树是二叉树，而ID3和C4.5算法生成的决策树不一定是二叉树。</p><h4 id="特征选择-1"><a href="#特征选择-1" class="headerlink" title="特征选择"></a>特征选择</h4><p>&emsp;&emsp;CART算法的决策规则由基尼指数决定，选择基尼指数最小的特征及其切分点作为最优特征和最优切分点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Gini_index</span><span class="params">(y_data)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Gini_index函数的主要作用是计算数据集的基尼指数</span></span><br><span class="line"><span class="string">    :param y_data: 数据集类别</span></span><br><span class="line"><span class="string">    :return: 返回基尼指数</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    m = len(y_data)</span><br><span class="line">    count = &#123;&#125;</span><br><span class="line">    num = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> y_data:</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> count:</span><br><span class="line">            count[i] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            count[i] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> count.keys():</span><br><span class="line">        num = num + pow(<span class="number">1.0</span> * count[item] / m,<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span>-num)</span><br></pre></td></tr></table></figure><p>在前面提到过ID3算法只能处理离散型特征，而CART算法既能处理离散型特征，又能处理连续型特征。CART算法处理连续型特征的方法与C4.5算法类似，都是将连续特征离散化，即将连续特征的所有取值进行排序，然后计算相邻取值的平均值作为切分点，在以此计算基尼指数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">ef Gini_D_A(x_data,y_data,feature):</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Gini_D_A函数的主要作用是计算某一离散特征各个取值的基尼指数，选取最优切分点</span></span><br><span class="line"><span class="string">    :param x_data: 数据集合</span></span><br><span class="line"><span class="string">    :param y_data: 数据集类别</span></span><br><span class="line"><span class="string">    :param feature: 特征</span></span><br><span class="line"><span class="string">    :return: 该特征的最优切分点</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    Gini_data = list(x_data[:,feature])</span><br><span class="line">    y_data = list(y_data[:])</span><br><span class="line">    m = len(Gini_data)</span><br><span class="line">    Gini = &#123;&#125;</span><br><span class="line">    classfy_data = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> range(m):</span><br><span class="line">        <span class="keyword">if</span> Gini_data[e] <span class="keyword">not</span> <span class="keyword">in</span> classfy_data:</span><br><span class="line">            classfy_data[Gini_data[e]] = []</span><br><span class="line">        classfy_data[Gini_data[e]].append(y_data[e])</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> classfy_data.keys():</span><br><span class="line">        l1 = len(classfy_data[item])</span><br><span class="line">        r = y_data[:]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> classfy_data[item]:</span><br><span class="line">            r.remove(i)</span><br><span class="line">        l2 = len(r)</span><br><span class="line">        num = <span class="number">1.0</span> * l1 / m * Gini_index(classfy_data[item]) + <span class="number">1.0</span> * l2 / m * Gini_index(r)</span><br><span class="line">        Gini[item] = num</span><br><span class="line">    sor = sorted(Gini.items(), key=operator.itemgetter(<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> sor[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Gini_continuous</span><span class="params">(x_data,y_data,feature)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Gini_continous函数的主要作用是计算某一连续特征各个取值的基尼指数，选取最优切分点</span></span><br><span class="line"><span class="string">    :param x_data: 数据集合</span></span><br><span class="line"><span class="string">    :param y_data: 数据集类别</span></span><br><span class="line"><span class="string">    :param feature: 特征</span></span><br><span class="line"><span class="string">    :return: 该特征的最优切分点</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    Gini_data = list(x_data[:,feature])</span><br><span class="line">    m = len(Gini_data)</span><br><span class="line">    y_data = list(y_data[:])</span><br><span class="line">    sort_data = sorted(Gini_data)</span><br><span class="line">    Gini = &#123;&#125;</span><br><span class="line">    split_point = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m<span class="number">-1</span>):</span><br><span class="line">        num = (sort_data[i] + sort_data[i+<span class="number">1</span>]) / <span class="number">2.0</span></span><br><span class="line">        split_point.append(num)</span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> split_point:</span><br><span class="line">        count_y = &#123;<span class="number">0</span>:[],<span class="number">1</span>:[]&#125;</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">if</span> Gini_data[k] &lt;= e:</span><br><span class="line">                count_y[<span class="number">0</span>].append(y_data[k])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count_y[<span class="number">1</span>].append(y_data[k])</span><br><span class="line">        cal = <span class="number">1.0</span> * len(count_y[<span class="number">0</span>]) / m * Gini_index(count_y[<span class="number">0</span>]) + <span class="number">1.0</span> * len(count_y[<span class="number">1</span>]) / m * Gini_index(count_y[<span class="number">1</span>])</span><br><span class="line">        Gini[e] = cal</span><br><span class="line">    sor = sorted(Gini.items(), key=operator.itemgetter(<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> sor[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>当数据集中同时含有离散型变量和连续型变量时，进行特征选择就稍微有些复杂了，以下便是特征选择的代码,这里需要注意的是对不同类型特征的标识和对计算基尼指数时返回值的统一处理。dis_or_con是一个列表，用来标识特征是连续型还是离散型，0表示离散，1表示连续。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">choose_feature</span><span class="params">(x_data,y_data,dis_or_con)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    choose_feature函数的主要作用是从各个特征的各个切分点中选择基尼指数最小的切分点</span></span><br><span class="line"><span class="string">    :param x_data: 数据集合</span></span><br><span class="line"><span class="string">    :param y_data: 数据类别</span></span><br><span class="line"><span class="string">    :return: 切分点</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    w = np.size(x_data,axis=<span class="number">1</span>)</span><br><span class="line">    count = []</span><br><span class="line">    count_label = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(w):</span><br><span class="line">        <span class="keyword">if</span> dis_or_con[i] == <span class="number">0</span>:</span><br><span class="line">            a = Gini_D_A(x_data,y_data,i)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            a = Gini_continuous(x_data,y_data,i)</span><br><span class="line">        count.append(a[<span class="number">1</span>])</span><br><span class="line">        count_label[i] = a</span><br><span class="line">    id = count.index(min(count))</span><br><span class="line">    <span class="keyword">return</span> id,count_label[id][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h4 id="决策树的生成-1"><a href="#决策树的生成-1" class="headerlink" title="决策树的生成"></a>决策树的生成</h4><p>&emsp;&emsp;决策树的生成大致与ID3算法类似</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_tree</span><span class="params">(x_data,y_data,dis_or_con_data,feature_list_data)</span>:</span></span><br><span class="line"></span><br><span class="line">    feature_list = feature_list_data[:]</span><br><span class="line">    dis_or_con = dis_or_con_data[:]</span><br><span class="line">    <span class="keyword">if</span> dis_or_con == []:</span><br><span class="line">        <span class="keyword">return</span> most_y_data(y_data)</span><br><span class="line">    <span class="keyword">if</span> is_all_same(y_data):</span><br><span class="line">        <span class="keyword">return</span> y_data[<span class="number">0</span>]</span><br><span class="line">    w,f = choose_feature(x_data,y_data,dis_or_con)</span><br><span class="line">    count_x, count_y = feature_split(x_data,y_data,w,f,dis_or_con[w])</span><br><span class="line">    node_name = feature_list[w]</span><br><span class="line">    tree = &#123;(node_name,f):&#123;&#125;&#125;</span><br><span class="line">    <span class="keyword">del</span> feature_list[w]</span><br><span class="line">    <span class="keyword">del</span> dis_or_con[w]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> count_x.keys():</span><br><span class="line">        fealist = feature_list[:]</span><br><span class="line">        dis_con = dis_or_con[:]</span><br><span class="line">        count_x_del = del_feature(count_x[i], w)</span><br><span class="line">        tree[(node_name,f)][i] = create_tree(count_x_del, count_y[i], dis_con,fealist)</span><br><span class="line">    <span class="keyword">return</span> tree</span><br></pre></td></tr></table></figure><h4 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h4><p>&emsp;&emsp;本文暂未实现剪枝算法，有待后续补充</p>]]></content:encoded>
      
      <comments>https://chaoge123456.github.io/%E5%86%B3%E7%AD%96%E6%A0%91.html/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
